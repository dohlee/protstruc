{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProtStruc","text":""},{"location":"#what-is-protstruc","title":"What is ProtStruc?","text":"<p>ProtStruc is a Python package for handling protein structures, especially for deep learning applications, through a simple, flexible, and efficient representation of protein structures.</p> <p>There are many ways to represent protein structures in various deep learning applications:</p> Year &amp; Source Category Deep learning application Protein structure representation 2020, PNAS Structure prediction TrRoseTTA Inter-residue geometry 2021, Science Structure prediction RoseTTAFold Inter-residue geometry 2021, Nature Structure prediction AlphaFold2 Orientation &amp; translation of backbone frames centered at Ca's 2022, Patterns Structure prediction DeepAb Inter-residue geometry 2023, Nat. Commun. Antibody structure prediction IgFold Oritentation &amp; translation of backbone frames centered at Ca's 2022, arXiv Structure generation FoldingDiff Three backbone dihedrals and three bond angles 2022, NeurIPS Structure generation DiffAb Orientation &amp; translation of backbone frames centered at Ca's 2022, Science Inverse-folding ProteinMPNN k-nearest neighbor graph 2022, arXiv Inverse-folding PiFold Inter-atomic/residue distance, backbone dihedrals and bond angles, orientation of residue frame, inter-residue orientations 2023, Science Structure prediction ESMFold Orientation &amp; translation of backbone frames centered at Ca's 2023, ICML Structure generation FrameDiff Orientation &amp; translation of backbone frames centered at Ca's, an additional torsion angle for oxygen atom 2022, ICML Structure generation Hierarchical Equivariant Refinement Network (HERN) 2022, arXiv Sequence-structure co-design Multi-channel Equivariant Attention Network (MEAN) 2023, ICML Sequence-structure co-design Dynamic multi-channel Equivariant Attention Network (dyMEAN)"},{"location":"getting-started/installation/","title":"Installation","text":"<p>ProtStruc is available on PyPI and can be installed with pip.</p> <pre><code>$ pip install protstruc\n</code></pre>"},{"location":"getting-started/installation/#testing","title":"Testing","text":"<p>Once you have installed ProtStruc, you can test your installation by running the following command:</p> <pre><code>$ pytest </code></pre>"},{"location":"home/examples/","title":"Examples","text":""},{"location":"home/examples/#initialize-a-single-protein-structure-from-a-pdb-file","title":"Initialize a single protein structure from a PDB file","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_file = '1a0s.pdb'\nbatch = ps.StructureBatch.from_pdb(pdb_file)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-a-list-of-pdb-files","title":"Initialize a batch of protein structures from a list of PDB files","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_files = ['1a0s.pdb', '1a1s.pdb', '1a2s.pdb', '1a3s.pdb', '1a4s.pdb']\nbatch = ps.StructureBatch.from_pdb(pdb_files)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-backbone-or-full-atom-xyz-coordinates","title":"Initialize a batch of protein structures from backbone (or full atom) xyz coordinates","text":"<pre><code>import torch\nimport protstruc as ps\n\nbatch_size, max_n_residues = 32, 100\nmax_n_atoms_per_residue = 10\n\nxyz = torch.randn(batch_size, max_n_residues, max_n_atoms_per_residue, 3)\n\nbatch = ps.StructureBatch.from_xyz(xyz)\n</code></pre>"},{"location":"reference/geometry/","title":"protstruc.geometry","text":"<p>Utility functions for computing 3D geometry of protein structures.</p> <p>This module contains the following functions:</p> <ul> <li><code>angle(a, b, c, to_degree=False)</code>: Compute planar angles between three points.</li> <li><code>dihedral(a, b, c, d, to_degree=False)</code>: Compute dihedral angle between four points.</li> <li><code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>: Place a fourth atom X given three atoms (A, B and C) and     the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</li> </ul>"},{"location":"reference/geometry/#protstruc.geometry.angle","title":"<code>angle(a, b, c, to_degree=False)</code>","text":"<p>Compute planar angles (0 ~ pi) between three (array of) points a, b and c.</p> Note <p>The planar angle is computed as the angle between the vectors <code>ab</code> and <code>bc</code> using the dot product followed by <code>torch.arccos</code>. If <code>to_degree</code> is False, the output is in radians between 0 and pi. Otherwise, the output is in degrees between 0 and 180.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a. Shape: (n, 3)</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b. Shape: (n, 3)</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c. Shape: (n, 3)</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return angles in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Planar angle between three points. Shape: (n,)</p>"},{"location":"reference/geometry/#protstruc.geometry.dihedral","title":"<code>dihedral(a, b, c, d, to_degree=False)</code>","text":"<p>Compute dihedral angle (-pi ~ pi) between (array of) four points a, b, c and d.</p> Note <p>The dihedral angle is the angle in the clockwise direction of the fourth atom compared to the first atom, while looking down the axis of the second to the third.</p> <p>The dihedral angle is computed as the angle between the plane defined by vectors <code>ba</code> and <code>bc</code> and the plane defined by vectors <code>bc</code> and <code>cd</code>. In short, the dihedral angle (theta) is obtained by first computing cos(theta) and sin(theta) using dot and cross products of the normal vectors of the two planes, and then computing theta using <code>torch.atan2</code>.</p> Tip <p>Here is a nice explanation of the computation of dihedral angles: https://leimao.github.io/blog/Dihedral-Angles</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>d</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom d (shape: (n, 3))</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return dihedrals in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Dihedral angle between four points. (shape: (n,))</p>"},{"location":"reference/geometry/#protstruc.geometry.fix_chirality","title":"<code>fix_chirality(coords)</code>","text":"<p>Fix chirality of the backbone so that all the phi dihedrals are negative.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>np.array</code> <p>Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Fixed coordinates.</p>"},{"location":"reference/geometry/#protstruc.geometry.gram_schmidt","title":"<code>gram_schmidt(a, b, c)</code>","text":"<p>Given three xyz coordinates, compute the orthonormal basis using Gram-Schmidt process. Specifically, compute the orthonormal basis of the plane defined by vectors (c - b) and (a - b).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>b</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>c</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <p>Returns:</p> Type Description <code>torch.FloatTensor</code> <p>Orthonormal basis of the plane defined by vectors <code>c - b</code> and <code>a - b</code>. Shape: (*, 3, 3)</p>"},{"location":"reference/geometry/#protstruc.geometry.ideal_backbone_coordinates","title":"<code>ideal_backbone_coordinates(size, include_cb=False)</code>","text":"<p>Return a batch of ideal backbone coordinates (N, Ca, C and optionally Cb) with a given batch size and number of residues.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Union[Tuple[int], List[int]]</code> required <code>include_cb</code> <code>bool</code> <p>Whether to include Cb atom in the frame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Union[np.array, torch.Tensor]</code> <p>A batch of ideal backbone coordinates (N, Ca, C and optionally Cb).</p> <code>Shape</code> <code>Union[np.array, torch.Tensor]</code> <p>(batch_size, num_residues, 3, 3) if <code>include_cb</code> is False, otherwise (batch_size, num_residues, 4, 3).</p>"},{"location":"reference/geometry/#protstruc.geometry.ideal_local_frame","title":"<code>ideal_local_frame()</code>","text":"<p>Compute ideal local coordinate system of a residue centered at N</p> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Local coordinate system of a residue centered at N, with atom order N, CA, C, CB (shape: (4, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.initialize_backbone_with_mds","title":"<code>initialize_backbone_with_mds(dist_mat, max_iter=500)</code>","text":"<p>Given a pairwise distance matrix of backbone atoms, initialize the coordinates of the backbone atoms using multidimensional scaling.</p> <p>Parameters:</p> Name Type Description Default <code>dist_mat</code> <code>np.array</code> <p>Pairwise distance matrix of backbone atoms (shape: (3, 3, L, L)).</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of iterations for MDS. Defaults to 500.</p> <code>500</code> <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p>"},{"location":"reference/geometry/#protstruc.geometry.place_fourth_atom","title":"<code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>","text":"<p>Place a fourth atom X given three atoms (A, B and C) and the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.array</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>np.array</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>np.array</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>length</code> <code>np.array</code> <p>Length of the bond between atom c and the new atom (shape: (n, 1)) i.e., bond length CX</p> required <code>planar</code> <code>np.array</code> <p>Planar angle between the new atom and the bond between atom c and the new atom (shape: (n, 1)) i.e., angle XCB</p> required <code>dihedral</code> <code>np.array</code> <p>Dihedral angle between the new atom and the plane defined by atoms a, b, and c (shape: (n, 1)) i.e., dihedral angle between planes XCB and ACB</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>3D coordinates of the new atom X (shape: (n, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.reconstruct_backbone_distmat_from_interresidue_geometry","title":"<code>reconstruct_backbone_distmat_from_interresidue_geometry(d_cb, omega, theta, phi, mask=None, chain_breaks=None)</code>","text":"<p>Reconstruct the backbone distance matrix from interresidue geometry including Cb distance matrix (<code>d_cb</code>), Ca-Cb-Ca'-Cb' dihedral (<code>omega</code>), N-Ca-Cb-Cb' dihedral (<code>theta</code>), and Ca-Cb-Cb' planar angle (<code>phi</code>).</p> <p>Parameters:</p> Name Type Description Default <code>d_cb</code> <code>np.array</code> <p>Cb distance matrix (shape: (L, L))</p> required <code>omega</code> <code>np.array</code> <p>Ca-Cb-Ca'-Cb' dihedral matrix (shape: (L, L))</p> required <code>theta</code> <code>np.array</code> <p>N-Ca-Cb-Cb' dihedral matrix (shape: (L, L))</p> required <code>phi</code> <code>np.array</code> <p>Ca-Cb-Cb' planar angle matrix (shape: (L, L))</p> required <code>mask</code> <code>np.array</code> <p>Mask for valid residue pairs, i.e., pairs of residues whose distance can be reconstructed from interresidue geometry (shape: (L, L))</p> <code>None</code> <code>chain_breaks</code> <code>list</code> <p>List of chain breaks, i.e., indices of residues that are not in the same chain with the next one.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.array</code> <p>Backbone distance matrix representing the distance between N, Ca, C atoms between residues (shape: (3, 3, L, L))</p>"},{"location":"reference/io/","title":"protstruc.io","text":""},{"location":"reference/io/#protstruc.io.infill_chain_idx","title":"<code>infill_chain_idx(chain_idx)</code>","text":"<p>Infill the chain index tensor to fill in the gaps.</p>"},{"location":"reference/io/#protstruc.io.pdb_to_xyz","title":"<code>pdb_to_xyz(filename)</code>","text":"<p>Parse a PDB file and return a tensor containing 3D coordinates of atoms.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to a PDB file.</p> required <p>Returns:</p> Name Type Description <code>atom_xyz</code> <code>torch.Tensor</code> <p>A xyz coordinate tensor. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE, 3).</p> <code>atom_mask</code> <code>torch.BoolTensor</code> <p>A mask tensor. 1 if the corresponding atom exists, 0 otherwise. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE)</p> <code>chain_idx</code> <code>torch.LongTensor</code> <p>A LongTensor containing chain indices per residue. Shape (n_residues,)</p> <code>chain_ids</code> <code>List[str]</code> <p>A list of unique chain IDs in the order of integers appearing in the <code>chain_idx</code> tensor.</p> <code>seq</code> <code>Dict[str, str]</code> <p>A dictionary mapping chain IDs to amino acid sequences.</p> Note <p><code>MAX_N_ATOMS_PER_RESIDUE</code> is set to 15 by default.</p>"},{"location":"reference/io/#protstruc.io.to_pdb","title":"<code>to_pdb(filename, coords, sequences, chain_ids, atoms=['N', 'CA', 'C', 'O', 'CB'])</code>","text":"<p>Save coordinates to a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output PDB file.</p> required <code>coords</code> <code>np.array</code> <p>Coordinates of shape (5, L, 3), where the first dimension denotes the atom type.</p> required <code>atoms</code> <code>List</code> <p>Defaults to [\"N\", \"CA\", \"C\", \"O\", \"CB\"].</p> <code>['N', 'CA', 'C', 'O', 'CB']</code>"},{"location":"reference/protstruc/","title":"protstruc.protstruc","text":""},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch","title":"<code>StructureBatch</code>","text":"<p>A batch of protein structures.</p> <p>This class provides an interface to initialize from and represent a batch of protein structures with various types of representations:</p> StructureBatch object can be initialized with <ul> <li>A single PDB file or a list of PDB files <code>StructureBatch.from_pdb</code></li> <li>A pdb identifier or a list of PDB identifiers <code>StructureBatch.from_pdb_id</code> (TODO)</li> <li>Backbone or full atom 3D coordinates <code>StructureBatch.from_xyz</code></li> <li>Dihedral angles <code>StructureBatch.from_dihedrals</code> (TODO)</li> </ul>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_xyz","title":"<code>from_xyz(xyz, atom_mask=None, chain_idx=None, chain_ids=None, seq=None)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a 3D coordinate array.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a numpy array of atom 3D coordinates.</p> <pre><code>&gt;&gt;&gt; batch_size, n_max_res, n_max_atoms = 2, 10, 25\n&gt;&gt;&gt; xyz = np.random.randn(batch_size, n_max_res, n_max_atoms, 3)\n&gt;&gt;&gt; sb = StructureBatch.from_xyz(xyz)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms, 3)</p> required <code>atom_mask</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms)</p> <code>None</code> <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain indices for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code> <code>seq</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_pdb","title":"<code>from_pdb(pdb_path)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB file or a list of PDB files.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a single PDB file,</p> <pre><code>&gt;&gt;&gt; pdb_path = '1a0a.pdb'\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_path)\n</code></pre> <p>or with a list of PDB files.</p> <pre><code>&gt;&gt;&gt; pdb_paths = ['1a0a.pdb', '1a0b.pdb']\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_paths)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_path</code> <code>Union[str, List[str]]</code> <p>Path to a PDB file or a list of paths to PDB files.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_pdb_id","title":"<code>from_pdb_id(pdb_id)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB ID or a list of PDB IDs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pdb_id = \"2ZIL\"  # Human lysozyme\n&gt;&gt;&gt; sb = StructureBatch.from_pdb_id(pdb_id)\n&gt;&gt;&gt; xyz = sb.get_xyz()\n&gt;&gt;&gt; xyz.shape\ntorch.Size([1, 130, 15, 3])\n&gt;&gt;&gt; dihedrals, dihedral_mask = sb.backbone_dihedrals()\n&gt;&gt;&gt; dihedrals.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.sum()\ntensor(3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_id</code> <code>Union[str, List[str]]</code> <p>A PDB identifier or a list of PDB identifiers.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_backbone_orientations_translations","title":"<code>from_backbone_orientations_translations(orientations, translations, chain_idx=None, chain_ids=None, seq=None)</code>  <code>classmethod</code>","text":"<p>Initialize a StructureBatch from an array of backbone orientations and translations.</p> <p>Parameters:</p> Name Type Description Default <code>orientations</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, 3, 3)</p> required <code>translations</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, 3)</p> required <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain identifiers for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code> <code>seq</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_dihedrals","title":"<code>from_dihedrals(dihedrals, chain_idx=None, chain_ids=None)</code>  <code>classmethod</code>","text":"<p>Initialize a StructureBatch from a dihedral angle array.</p> <p>Parameters:</p> Name Type Description Default <code>dihedrals</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_dihedrals)</p> required <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain identifiers for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_seq","title":"<code>get_seq()</code>","text":"<p>Return the amino acid sequence of proteins.</p> <p>Returns:</p> Name Type Description <code>seq_dict</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_total_lengths","title":"<code>get_total_lengths()</code>","text":"<p>Return the total sum of chain lengths for each protein.</p> Note <p>This counts the number of missing residues in the middle of a chain, but does not count the missing residues at the beginning and end of a chain.</p> <p>Returns:</p> Name Type Description <code>total_lengths</code> <code>torch.LongTensor</code> <p>A tensor containing the total length of each protein. Shape: (batch_size,)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_n_terminal_mask","title":"<code>get_n_terminal_mask()</code>","text":"<p>Return a boolean mask for the N-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting N-terminal residues. <code>True</code> if N-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_c_terminal_mask","title":"<code>get_c_terminal_mask()</code>","text":"<p>Return a boolean mask for the C-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting C-terminal residues. <code>True</code> if C-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.pairwise_distance_matrix","title":"<code>pairwise_distance_matrix()</code>","text":"<p>Return the all-atom pairwise pairwise distance matrix between residues.</p> Info <p>Distances are measured in Angstroms.</p> <p>Examples:</p> <p><code>dist[:, :, 1, 1]</code> will give pairwise alpha-carbon distance matrix between residues, as the index <code>1</code> corresponds to the alpha-carbon atom. <pre><code>&gt;&gt;&gt; structure_batch = StructureBatch.from_pdb(\"1a8o.pdb\")\n&gt;&gt;&gt; dist = structure_batch.pairwise_distance_matrix()\n&gt;&gt;&gt; ca_dist = dist[:, :, 1, 1]  # 1 = CA_IDX\n</code></pre></p> <p>Returns:</p> Name Type Description <code>dist</code> <code>torch.FloatTensor</code> <p>A tensor containing an all-atom pairwise distance matrix for each pair of residues. A distance between atom <code>a</code> of residue <code>i</code> and atom <code>b</code> of residue <code>j</code> is given by <code>dist[i, j, a, b]</code>. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p> <code>dist_mask</code> <code>torch.BoolTensor</code> <p>A boolean tensor denoting which distances are valid. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_dihedrals","title":"<code>backbone_dihedrals()</code>","text":"<p>Return the backbone dihedral angles phi, psi and omega for each residue.</p> Info <p>Dihedral angles are measured in radians and are in the range <code>[-pi, pi]</code>.</p> <p>For a quick reminder of the definition of the dihedral angles, refer to the following image: </p> <p>Source: Fabian Fuchs</p> Note <p><code>phi</code> angles are not defined for the first residue (it needs a predecessor) and <code>psi</code> and <code>omega</code> angles are not defined for the last residue (they need successors). Those invalid angles can be filtered using the <code>dihedral_mask</code> tensor returned from the method.</p> Warning <p>Dihedral angles involving the residues at the chain breaks are not handled correctly for now.</p> <p>Returns:</p> Name Type Description <code>dihedrals</code> <code>torch.FloatTensor</code> <p>A tensor containing <code>phi</code>, <code>psi</code> and <code>omega</code> dihedral angles for each residue. Shape: (batch_size, num_residues, 3)</p> <code>dihedral_mask</code> <code>torch.FloatTensor</code> <p>A tensor containing a boolean mask for the dihedral angles. <code>True</code> if the corresponding dihedral angle is defined, <code>False</code> otherwise. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_orientations","title":"<code>backbone_orientations(a1='N', a2='CA', a3='C')</code>","text":"<p>Return the orientation of the backbone for each residue.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>str</code> <p>First atom used to determine backbone orientation. Defaults to 'N'.</p> <code>'N'</code> <code>a2</code> <code>str</code> <p>Second atom used to determine backbone orientation. Defaults to 'CA'.</p> <code>'CA'</code> <code>a3</code> <code>str</code> <p>Third atom used to determine backbone orientation. Defaults to 'C'.</p> <code>'C'</code> Note <p>The backbone orientations are determined by using Gram-Schmidt orthogonalization on the vectors <code>a3 - a2</code> and <code>a1 - a2</code>. Note that <code>a3 - a2</code> forms the first basis, and <code>a1 - a2</code> - proj_{a3 - a2}(a1 - a2) forms the second basis. The third basis is formed by taking the cross product of the first and second basis vectors.</p> <p>Returns:</p> Name Type Description <code>bb_orientations</code> <code>torch.FloatTensor</code> <p>A tensor containing the local reference backbone orientation for each residue.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_translations","title":"<code>backbone_translations(atom='CA')</code>","text":"<p>Return the coordinate (translation) of a given backbone atom for each residue.</p> Note <p>Reference atom is set to the alpha-carbon (CA) by default.</p> <p>Parameters:</p> Name Type Description Default <code>atom</code> <code>str</code> <p>Type of atom used to determine backbone translation. Defaults to 'CA'.</p> <code>'CA'</code> <p>Returns:</p> Name Type Description <code>bb_translations</code> <code>torch.FloatTensor</code> <p>xyz coordinates (translations) of a specified backbone atoms. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.translate","title":"<code>translate(translation, atomwise=False)</code>","text":"<p>Translate the structures by a given tensor of shape (batch_size, num_residues, 3) Translation is performed residue-wise by default, but atomwise translation can be performed when <code>atomwise=True</code>. In that case, the translation tensor should have a shape of (batch_size, num_residues, num_atom, 3).</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>torch.Tensor</code> <p>Translation vector. Shape: (batch_size, num_residues, 3) if <code>atomwise=False</code>, (batch_size, num_residues, num_atom, 3) otherwise.</p> required"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.standardize","title":"<code>standardize()</code>","text":"<p>Standardize the coordinates of the structures to have zero mean and unit standard deviation.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.unstandardize","title":"<code>unstandardize()</code>","text":"<p>Recover the coordinates at original scale from teh standardized coordinates.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.inter_residue_dihedrals","title":"<code>inter_residue_dihedrals(use_cb=False)</code>","text":"<p>Return the inter-residue dihedral angles.</p> <p>Parameters:</p> Name Type Description Default <code>use_cb</code> <code>bool</code> <p>Use CB atom instead of CA. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Shape</code> <p>(batch_size, num_residues, num_residues, 2)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.AntibodyFvStructure","title":"<code>AntibodyFvStructure</code>","text":""},{"location":"reference/protstruc/#protstruc.protstruc.AntibodyFvStructure.inter_residue_geometry","title":"<code>inter_residue_geometry(to_degree=False)</code>","text":"<p>https://github.com/RosettaCommons/RoseTTAFold/blob/main/network/kinematics.py</p>"},{"location":"tutorials/backbone_orientations_and_translations/","title":"Backbone orientations/translations","text":"<p>In this tutorial, we learn how to obtain backbone orientations and translations from protein structures using <code>protstruc</code>. For each residue, a 3x3 backbone orientation matrix is defined by a Gram-Schmidt orthonormalized basis of two vectors: N-Ca and C-Ca vectors. Meanwhile, a three-element translation vector is simply defined as a coordinate of the Ca atom.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import protstruc as ps import matplotlib.pyplot as plt import numpy as np <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) In\u00a0[3]: Copied! <pre>orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C').numpy()\ntranslations = sb.backbone_translations(atom='CA').numpy()\n\norientations.shape, translations.shape\n</pre> orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C').numpy() translations = sb.backbone_translations(atom='CA').numpy()  orientations.shape, translations.shape Out[3]: <pre>((2, 184, 3, 3), (2, 184, 3))</pre> In\u00a0[4]: Copied! <pre>from itertools import combinations\nfor i, j in combinations([0, 1, 2], 2):\n    inner_products = (orientations[:, :, :, i] * orientations[:, :, :, j]).sum(axis=2)\n\n    assert np.allclose(inner_products[~np.isnan(inner_products)], 0.0, atol=1e-6)\n</pre> from itertools import combinations for i, j in combinations([0, 1, 2], 2):     inner_products = (orientations[:, :, :, i] * orientations[:, :, :, j]).sum(axis=2)      assert np.allclose(inner_products[~np.isnan(inner_products)], 0.0, atol=1e-6) In\u00a0[5]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nprt_idx = 1\nchain_idx = sb.get_chain_idx()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n    # plot backbone CA atoms \n    ax.plot(\n        translations[prt_idx, chain_mask, 0],\n        translations[prt_idx, chain_mask, 1],\n        translations[prt_idx, chain_mask, 2],\n    )\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  prt_idx = 1 chain_idx = sb.get_chain_idx()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx     # plot backbone CA atoms      ax.plot(         translations[prt_idx, chain_mask, 0],         translations[prt_idx, chain_mask, 1],         translations[prt_idx, chain_mask, 2],     ) In\u00a0[16]: Copied! <pre>sb = ps.StructureBatch.from_pdb('4EOT.pdb')\nt = sb.backbone_translations()[0].numpy()\no = sb.backbone_orientations()[0].numpy()\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(111, projection='3d')\n\nprt_idx = 0\nchain_idx = sb.get_chain_idx()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n        \n    x, y, z = t[chain_mask, 0], t[chain_mask, 1], t[chain_mask, 2]\n    o_x, o_y, o_z = o[chain_mask, :, 0], o[chain_mask, :, 1], o[chain_mask, :, 2]\n\n    lw, length = 0.75, 1.5\n    ax.quiver(x, y, z, o_x[:, 0], o_x[:, 1], o_x[:, 2], color='C0', linewidth=lw, length=length)\n    ax.quiver(x, y, z, o_y[:, 0], o_y[:, 1], o_y[:, 2], color='C1', linewidth=lw, length=length)\n    ax.quiver(x, y, z, o_z[:, 0], o_z[:, 1], o_z[:, 2], color='C2', linewidth=lw, length=length)\n\n    ax.plot(x, y, z, c='C7', linewidth=0.5)\n    ax.view_init(30, 30)\n</pre> sb = ps.StructureBatch.from_pdb('4EOT.pdb') t = sb.backbone_translations()[0].numpy() o = sb.backbone_orientations()[0].numpy()  fig = plt.figure(figsize=(10, 10)) ax = fig.add_subplot(111, projection='3d')  prt_idx = 0 chain_idx = sb.get_chain_idx()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx              x, y, z = t[chain_mask, 0], t[chain_mask, 1], t[chain_mask, 2]     o_x, o_y, o_z = o[chain_mask, :, 0], o[chain_mask, :, 1], o[chain_mask, :, 2]      lw, length = 0.75, 1.5     ax.quiver(x, y, z, o_x[:, 0], o_x[:, 1], o_x[:, 2], color='C0', linewidth=lw, length=length)     ax.quiver(x, y, z, o_y[:, 0], o_y[:, 1], o_y[:, 2], color='C1', linewidth=lw, length=length)     ax.quiver(x, y, z, o_z[:, 0], o_z[:, 1], o_z[:, 2], color='C2', linewidth=lw, length=length)      ax.plot(x, y, z, c='C7', linewidth=0.5)     ax.view_init(30, 30)"},{"location":"tutorials/backbone_orientations_and_translations/#extracting-backbone-orientations-and-translations-from-structurebatch-object","title":"Extracting backbone orientations and translations from <code>StructureBatch</code> object\u00b6","text":""},{"location":"tutorials/backbone_orientations_and_translations/#orthogonality-of-residue-frames-orientations","title":"Orthogonality of residue frames (orientations)\u00b6","text":"<p>Let's check whether vectors forming residue frames (which represent the orientation of residues) are orthogonal for each others.</p>"},{"location":"tutorials/backbone_orientations_and_translations/#visualizing-both-the-orientations-and-translations-of-residues","title":"Visualizing both the orientations and translations of residues\u00b6","text":""},{"location":"tutorials/diffusing_xyz_coordinates/","title":"Diffusing XYZ coordinates with Gaussian noise","text":"<p>Many diffusion models for protein structure generation require a set of atom coordinates to be diffused with Gaussian noises having a predefined variance schedule, which finally results in a randomized set of coordinates distributed according to 3D Gaussian distribution. This tutorial shows how to use the <code>StructureBatch</code> object to generate a set of diffused coordinates.</p> In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport torch\n\nimport protstruc as ps\nfrom protstruc.general import ATOM\n</pre> import matplotlib.pyplot as plt import matplotlib.animation as animation import numpy as np import torch  import protstruc as ps from protstruc.general import ATOM <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>import math\n\ndef cosine_variance_schedule(T, s=8e-3, beta_max=0.999):\n    # cosine variance schedule\n    # T: total timesteps\n    # s: small offset to prevent beta from being too small\n    # beta_max: to prevent singularities at the end of the diffusion process\n    t = torch.arange(T + 1)  # 0, 1, ..., T\n\n    f_t = torch.cos((t / T + s) / (1 + s) * math.pi / 2.0).square()\n    alpha_bar = f_t / f_t[0]\n    beta = torch.cat(\n        [\n            torch.tensor([0.0]),\n            torch.clip(1 - alpha_bar[1:] / alpha_bar[:-1], min=1e-5, max=beta_max),\n        ]\n    )\n    alpha = 1 - beta\n\n    sched = {\n        \"alpha\": alpha,\n        \"alpha_bar\": alpha_bar,\n        \"alpha_bar_sqrt\": alpha_bar.sqrt(),\n        \"one_minus_alpha_bar_sqrt\": (1 - alpha_bar).sqrt(),\n        \"beta\": beta,\n    }\n    return sched\n</pre> import math  def cosine_variance_schedule(T, s=8e-3, beta_max=0.999):     # cosine variance schedule     # T: total timesteps     # s: small offset to prevent beta from being too small     # beta_max: to prevent singularities at the end of the diffusion process     t = torch.arange(T + 1)  # 0, 1, ..., T      f_t = torch.cos((t / T + s) / (1 + s) * math.pi / 2.0).square()     alpha_bar = f_t / f_t[0]     beta = torch.cat(         [             torch.tensor([0.0]),             torch.clip(1 - alpha_bar[1:] / alpha_bar[:-1], min=1e-5, max=beta_max),         ]     )     alpha = 1 - beta      sched = {         \"alpha\": alpha,         \"alpha_bar\": alpha_bar,         \"alpha_bar_sqrt\": alpha_bar.sqrt(),         \"one_minus_alpha_bar_sqrt\": (1 - alpha_bar).sqrt(),         \"beta\": beta,     }     return sched In\u00a0[3]: Copied! <pre>pdb_id = '4EOT'\nsb = ps.StructureBatch.from_pdb_id(pdb_id)\nprt_idx = 0\natom_idx = ATOM.CA\n\nfig = plt.figure(figsize=(14, 5))\nax1 = fig.add_subplot(131, projection='3d')\nax2 = fig.add_subplot(132, projection='3d')\nax3 = fig.add_subplot(133)\n\nsb.standardize()\n\nT = 1000\nsched = cosine_variance_schedule(T=T, s=8e-3, beta_max=0.999)\n\nims = []\nfor t in range(T):\n    # coordinates of Ca atoms\n    # xyz = sb.get_xyz().numpy()\n    xyz = sched['alpha_bar_sqrt'][t] * sb.get_xyz()\n    bsz, n_res = xyz.shape[:2]\n\n    # add random Gaussian noise to the coordinates \n    xyz += (1 - sched['alpha_bar'][t]) * torch.randn(bsz, n_res, 1, 3)\n\n    xyz = xyz.numpy()\n    ax1.set_title(f't={t}')\n    im1 = ax1.scatter(\n        xyz[prt_idx, :, atom_idx, 0],\n        xyz[prt_idx, :, atom_idx, 1],\n        xyz[prt_idx, :, atom_idx, 2],\n        c='C1'\n    )\n    ax2.set_title(f't={t}')\n    im2, = ax2.plot(\n        xyz[prt_idx, :, atom_idx, 0],\n        xyz[prt_idx, :, atom_idx, 1],\n        xyz[prt_idx, :, atom_idx, 2],\n        c='C1'\n    )\n    # histogram of x coordinates\n    _, _, im3 = ax3.hist(xyz[prt_idx, :, atom_idx, 0], bins=33, fc='C1')\n\n    # histogram patches (im3) is already a list, so just concatenate it\n    ims.append([im1, im2] + list(im3))\n\nani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000)\nani.save(f'animations/{pdb_id}_diffusion.gif')\n\nplt.clf()  # not showing the results after this cell\n</pre> pdb_id = '4EOT' sb = ps.StructureBatch.from_pdb_id(pdb_id) prt_idx = 0 atom_idx = ATOM.CA  fig = plt.figure(figsize=(14, 5)) ax1 = fig.add_subplot(131, projection='3d') ax2 = fig.add_subplot(132, projection='3d') ax3 = fig.add_subplot(133)  sb.standardize()  T = 1000 sched = cosine_variance_schedule(T=T, s=8e-3, beta_max=0.999)  ims = [] for t in range(T):     # coordinates of Ca atoms     # xyz = sb.get_xyz().numpy()     xyz = sched['alpha_bar_sqrt'][t] * sb.get_xyz()     bsz, n_res = xyz.shape[:2]      # add random Gaussian noise to the coordinates      xyz += (1 - sched['alpha_bar'][t]) * torch.randn(bsz, n_res, 1, 3)      xyz = xyz.numpy()     ax1.set_title(f't={t}')     im1 = ax1.scatter(         xyz[prt_idx, :, atom_idx, 0],         xyz[prt_idx, :, atom_idx, 1],         xyz[prt_idx, :, atom_idx, 2],         c='C1'     )     ax2.set_title(f't={t}')     im2, = ax2.plot(         xyz[prt_idx, :, atom_idx, 0],         xyz[prt_idx, :, atom_idx, 1],         xyz[prt_idx, :, atom_idx, 2],         c='C1'     )     # histogram of x coordinates     _, _, im3 = ax3.hist(xyz[prt_idx, :, atom_idx, 0], bins=33, fc='C1')      # histogram patches (im3) is already a list, so just concatenate it     ims.append([im1, im2] + list(im3))  ani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000) ani.save(f'animations/{pdb_id}_diffusion.gif')  plt.clf()  # not showing the results after this cell <pre>&lt;Figure size 1400x500 with 0 Axes&gt;</pre> <p>The animation below shows that the coordinates of Ca atoms gradually reaches to the Gaussian distribution.</p> <p></p>"},{"location":"tutorials/ideal_backbone_coordinates/","title":"Ideal backbone coordinates","text":"In\u00a0[3]: Copied! <pre>import protstruc as ps\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import protstruc as ps import numpy as np import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[64]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nx = np.zeros(1)\ny = np.zeros(1)\nz = np.zeros(1)\n\nu = np.array([1])\nv = np.array([1])\nw = np.array([1])\n\nax.quiver(x, y, z, u, np.zeros_like(u), np.zeros_like(u), color='C0')\nax.quiver(x, y, z, np.zeros_like(v), v, np.zeros_like(v), color='C3')\nax.quiver(x, y, z, np.zeros_like(w), np.zeros_like(w), w, color='C7')\n\nax.set_xlim([-5, 5])\nax.set_ylim([-5, 5])\nax.set_zlim([-5, 5])\n</pre> fig = plt.figure() ax = fig.add_subplot(111, projection='3d')  x = np.zeros(1) y = np.zeros(1) z = np.zeros(1)  u = np.array([1]) v = np.array([1]) w = np.array([1])  ax.quiver(x, y, z, u, np.zeros_like(u), np.zeros_like(u), color='C0') ax.quiver(x, y, z, np.zeros_like(v), v, np.zeros_like(v), color='C3') ax.quiver(x, y, z, np.zeros_like(w), np.zeros_like(w), w, color='C7')  ax.set_xlim([-5, 5]) ax.set_ylim([-5, 5]) ax.set_zlim([-5, 5]) Out[64]: <pre>(-5.0, 5.0)</pre> In\u00a0[84]: Copied! <pre>\n</pre> In\u00a0[85]: Copied! <pre>t.shape, o.shape\n</pre> t.shape, o.shape Out[85]: <pre>((130, 3), (130, 3, 3))</pre> In\u00a0[89]: Copied! <pre>\n</pre> Out[89]: <pre>[&lt;mpl_toolkits.mplot3d.art3d.Line3D at 0x7f931e98fc10&gt;]</pre> In\u00a0[83]: Copied! <pre>x\n</pre> x Out[83]: <pre>tensor([ 1.8990,  4.5970,  7.3730,  9.3340, 13.0930, 14.2340, 11.0910, 11.9820,\n        15.6550, 14.7970, 12.2110, 14.7700, 17.2960, 14.8170, 14.0890, 17.7640,\n        18.7180, 21.8240, 24.7570, 22.5640, 24.7420, 27.2100, 24.7150, 24.6580,\n        21.4290, 22.2490, 22.3540, 18.9070, 17.5980, 19.0100, 17.3020, 13.8370,\n        14.1040, 14.7250, 12.4990,  9.3660,  9.9890,  9.3740,  5.8190,  4.5460,\n         1.6420,  3.9170,  3.2710,  4.6540,  3.5020,  6.1040,  4.1550,  7.1660,\n         7.2970,  3.9250,  5.4000,  4.7090,  6.9820,  5.4150,  5.8700,  8.5650,\n        11.4140,  9.6180,  9.9370,  9.1430,  6.3450,  8.2900, 10.8620,  9.9350,\n         6.2460,  3.1780,  0.3470, -1.1860, -1.0430,  2.7000,  3.9920,  6.8530,\n         6.3780,  8.8740,  7.6340, 11.0270,  9.8040,  6.7270,  4.6050,  1.5010,\n         2.5260, -0.3620,  1.8250,  4.1590,  1.4620,  0.8810,  1.6990,  3.6940,\n         6.8910,  7.9380,  7.0910,  8.7430, 11.8830, 11.8750, 11.6100, 14.2600,\n        16.6040, 15.8320, 16.6310, 20.0880, 20.9540, 21.5150, 25.0880, 24.1230,\n        23.1070, 21.6720, 22.9150, 19.7130, 17.9450, 19.1200, 18.0590, 20.6600,\n        23.4410, 22.2270, 21.7860, 23.5060, 26.5150, 29.8260, 28.1070, 28.0140,\n        24.9060, 25.4500, 22.8650, 20.0400, 20.5930, 22.1040, 20.2410, 18.0890,\n        19.8510, 20.7160])</pre>"},{"location":"tutorials/pairwise_distance_matrix/","title":"Pairwise distance matrix","text":"<p>In this tutorial, we learn how to obtain pairwise distance matrix using <code>protstruc</code>.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\n\nfrom protstruc.general import ATOM, AA\nfrom biopandas.pdb import PandasPdb\n</pre> import protstruc as ps import matplotlib.pyplot as plt  from protstruc.general import ATOM, AA from biopandas.pdb import PandasPdb <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <p>Initialize a <code>StructureBatch</code> instance from a PDB IDs.</p> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\ndistmat, distmat_mask = sb.pairwise_distance_matrix()\n\ndistmat.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) distmat, distmat_mask = sb.pairwise_distance_matrix()  distmat.shape Out[2]: <pre>torch.Size([2, 184, 184, 15, 15])</pre> <p>Compute total number of residues for each protein.</p> In\u00a0[3]: Copied! <pre>total_lengths = sb.get_total_lengths()\ntotal_lengths\n</pre> total_lengths = sb.get_total_lengths() total_lengths Out[3]: <pre>tensor([130, 184])</pre> In\u00a0[4]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])     ax.set_title(pdb_ids[i]) In\u00a0[5]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])      ax.set_title(pdb_ids[i])"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-ca-atoms","title":"Pairwise distance matrix between Ca atoms\u00b6","text":"<p>Note that 4EOT has 2 chains, so the pairwise distance matrix shows horizontal and vertical split.</p>"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-cb-atoms","title":"Pairwise distance matrix between Cb atoms\u00b6","text":"<p>Note that glycine residue does not have $C_{\\beta}$ atom and thus the distance from/to glycine residue is not defined.</p>"},{"location":"tutorials/ramachandran_plot/","title":"Ramachandran plot","text":"<p>In this tutorial, we learn how to draw a Ramachandran plot by computing backbone dihedrals of a protein structure using <code>protstruc</code>.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import protstruc as ps import matplotlib.pyplot as plt import numpy as np <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n\ndihedrals, dihedral_mask = sb.backbone_dihedrals()\ndihedrals.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids)  dihedrals, dihedral_mask = sb.backbone_dihedrals() dihedrals.shape Out[2]: <pre>torch.Size([2, 184, 3])</pre> In\u00a0[4]: Copied! <pre>PHI_IDX, PSI_IDX = 0, 1\nfig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\nplt.subplots_adjust(wspace=0.3)\n</pre> PHI_IDX, PSI_IDX = 0, 1 fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')      ax = fig.add_subplot(1, 2, i+1)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])  plt.subplots_adjust(wspace=0.3) <pre>1REX has 128 residues valid for phi/psi plot.\n4EOT has 180 residues valid for phi/psi plot.\n</pre> In\u00a0[5]: Copied! <pre>import biotite.structure as struc\nfrom biotite.structure.io.pdb import PDBFile\nfrom biotite.database.rcsb import fetch\nfetch(pdb_ids, 'pdb', '.')\n</pre> import biotite.structure as struc from biotite.structure.io.pdb import PDBFile from biotite.database.rcsb import fetch fetch(pdb_ids, 'pdb', '.') Out[5]: <pre>['./1REX.pdb', './4EOT.pdb']</pre> In\u00a0[15]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\n    n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()\n    print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])      n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()     print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot') plt.subplots_adjust(wspace=0.3)  <pre>1REX has 128 residues valid for phi/psi plot\n4EOT has 180 residues valid for phi/psi plot\n</pre> In\u00a0[19]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(phi, my_phi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('phi (biotite)')\n    ax.set_ylabel('phi (ProtStruc)')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(phi, my_phi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('phi (biotite)')     ax.set_ylabel('phi (ProtStruc)') plt.subplots_adjust(wspace=0.3)  In\u00a0[18]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(psi, my_psi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('psi (biotite)')\n    ax.set_ylabel('psi (ProtStruc)')\n\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(psi, my_psi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('psi (biotite)')     ax.set_ylabel('psi (ProtStruc)')  plt.subplots_adjust(wspace=0.3)"},{"location":"tutorials/ramachandran_plot/#compute-backbone-dihedrals-using-backbone_dihedrals","title":"Compute backbone dihedrals using <code>backbone_dihedrals()</code>\u00b6","text":"<p><code>backbone_dihedrals()</code> computes backbone dihedrals of a given protein structure and returns a tensor of shape <code>(B, L, 3)</code> where B is the batch size and L is the length of the protein. The last dimension denotes the three backbone dihedrals $\\phi$, $\\psi$ and $\\omega$.</p>"},{"location":"tutorials/ramachandran_plot/#ramachandran-plots","title":"Ramachandran plots\u00b6","text":"<p>Now plotting a Ramachandran plot is straightforward.</p> <p>We can see that protein <code>4EOT</code> is mainly composed of alpha helices.</p>"},{"location":"tutorials/ramachandran_plot/#benchmarking-with-biotitestructure","title":"Benchmarking with <code>biotite.structure</code>\u00b6","text":"<p>Now we check if the backbone dihedrals computed from <code>protstruc</code> is consistent with the results from <code>biotite.structure</code>.</p>"}]}