{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProtStruc","text":""},{"location":"#what-is-protstruc","title":"What is ProtStruc?","text":"<p>ProtStruc is a Python package for handling protein structures, especially for deep learning applications, through a simple, flexible, and efficient representation of protein structures.</p> <p>There are many ways to represent protein structures in various deep learning applications:</p> Year &amp; Source Category Deep learning application Protein structure representation 2020, PNAS Structure prediction TrRoseTTA Inter-residue geometry 2021, Science Structure prediction RoseTTAFold Inter-residue geometry 2021, Nature Structure prediction AlphaFold2 Orientation &amp; translation of backbone frames centered at Ca's 2022, Patterns Structure prediction DeepAb Inter-residue geometry 2023, Nat. Commun. Antibody structure prediction IgFold Oritentation &amp; translation of backbone frames centered at Ca's 2022, arXiv Structure generation FoldingDiff Three backbone dihedrals and three bond angles 2022, NeurIPS Structure generation DiffAb Orientation &amp; translation of backbone frames centered at Ca's 2022, Science Inverse-folding ProteinMPNN k-nearest neighbor graph 2022, arXiv Inverse-folding PiFold Inter-atomic/residue distance, backbone dihedrals and bond angles, orientation of residue frame, inter-residue orientations 2023, Science Structure prediction ESMFold Orientation &amp; translation of backbone frames centered at Ca's 2023, ICML Structure generation FrameDiff Orientation &amp; translation of backbone frames centered at Ca's, an additional torsion angle for oxygen atom Structure generation HERN 2022, arXiv Sequence-structure co-design Multi-channel Equivariant Attention Network (MEAN) 2023, ICML Sequence-structure co-design Dynamic multi-channel Equivariant Attention Network (dyMEAN)"},{"location":"getting-started/installation/","title":"Installation","text":"<p>ProtStruc is available on PyPI and can be installed with pip.</p> <pre><code>$ pip install protstruc\n</code></pre>"},{"location":"getting-started/installation/#testing","title":"Testing","text":"<p>Once you have installed ProtStruc, you can test your installation by running the following command:</p> <pre><code>$ pytest </code></pre>"},{"location":"home/examples/","title":"Examples","text":""},{"location":"home/examples/#initialize-a-single-protein-structure-from-a-pdb-file","title":"Initialize a single protein structure from a PDB file","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_file = '1a0s.pdb'\nbatch = ps.StructureBatch.from_pdb(pdb_file)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-a-list-of-pdb-files","title":"Initialize a batch of protein structures from a list of PDB files","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_files = ['1a0s.pdb', '1a1s.pdb', '1a2s.pdb', '1a3s.pdb', '1a4s.pdb']\nbatch = ps.StructureBatch.from_pdb(pdb_files)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-backbone-or-full-atom-xyz-coordinates","title":"Initialize a batch of protein structures from backbone (or full atom) xyz coordinates","text":"<pre><code>import torch\nimport protstruc as ps\n\nbatch_size, max_n_residues = 32, 100\nmax_n_atoms_per_residue = 10\n\nxyz = torch.randn(batch_size, max_n_residues, max_n_atoms_per_residue, 3)\n\nbatch = ps.StructureBatch.from_xyz(xyz)\n</code></pre>"},{"location":"reference/geometry/","title":"protstruc.geometry","text":"<p>Utility functions for computing 3D geometry of protein structures.</p> <p>This module contains the following functions:</p> <ul> <li><code>angle(a, b, c, to_degree=False)</code>: Compute planar angles between three points.</li> <li><code>dihedral(a, b, c, d, to_degree=False)</code>: Compute dihedral angle between four points.</li> <li><code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>: Place a fourth atom X given three atoms (A, B and C) and     the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</li> </ul>"},{"location":"reference/geometry/#protstruc.geometry.angle","title":"<code>angle(a, b, c, to_degree=False)</code>","text":"<p>Compute planar angles (0 ~ pi) between three (array of) points a, b and c.</p> Note <p>The planar angle is computed as the angle between the vectors <code>ab</code> and <code>bc</code> using the dot product followed by <code>torch.arccos</code>. If <code>to_degree</code> is False, the output is in radians between 0 and pi. Otherwise, the output is in degrees between 0 and 180.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a. Shape: (n, 3)</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b. Shape: (n, 3)</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c. Shape: (n, 3)</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return angles in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Planar angle between three points. Shape: (n,)</p>"},{"location":"reference/geometry/#protstruc.geometry.dihedral","title":"<code>dihedral(a, b, c, d, to_degree=False)</code>","text":"<p>Compute dihedral angle (-pi ~ pi) between (array of) four points a, b, c and d.</p> Note <p>The dihedral angle is the angle in the clockwise direction of the fourth atom compared to the first atom, while looking down the axis of the second to the third.</p> <p>The dihedral angle is computed as the angle between the plane defined by vectors <code>ba</code> and <code>bc</code> and the plane defined by vectors <code>bc</code> and <code>cd</code>. In short, the dihedral angle (theta) is obtained by first computing cos(theta) and sin(theta) using dot and cross products of the normal vectors of the two planes, and then computing theta using <code>torch.atan2</code>.</p> Tip <p>Here is a nice explanation of the computation of dihedral angles: https://leimao.github.io/blog/Dihedral-Angles</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>d</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom d (shape: (n, 3))</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return dihedrals in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Dihedral angle between four points. (shape: (n,))</p>"},{"location":"reference/geometry/#protstruc.geometry.fix_chirality","title":"<code>fix_chirality(coords)</code>","text":"<p>Fix chirality of the backbone so that all the phi dihedrals are negative.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>np.array</code> <p>Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Fixed coordinates.</p>"},{"location":"reference/geometry/#protstruc.geometry.gram_schmidt","title":"<code>gram_schmidt(a, b, c)</code>","text":"<p>Given three xyz coordinates, compute the orthonormal basis using Gram-Schmidt process. Specifically, compute the orthonormal basis of the plane defined by vectors (c - b) and (a - b).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>b</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>c</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <p>Returns:</p> Type Description <code>torch.FloatTensor</code> <p>Orthonormal basis of the plane defined by vectors (c - b) and (a - b). Shape: (*, 3, 3)</p>"},{"location":"reference/geometry/#protstruc.geometry.ideal_local_frame","title":"<code>ideal_local_frame()</code>","text":"<p>Compute ideal local coordinate system of a residue centered at N</p> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Local coordinate system of a residue centered at N, with atom order N, CA, C, CB (shape: (4, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.initialize_backbone_with_mds","title":"<code>initialize_backbone_with_mds(dist_mat, max_iter=500)</code>","text":"<p>Given a pairwise distance matrix of backbone atoms, initialize the coordinates of the backbone atoms using multidimensional scaling.</p> <p>Parameters:</p> Name Type Description Default <code>dist_mat</code> <code>np.array</code> <p>Pairwise distance matrix of backbone atoms (shape: (3, 3, L, L)).</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of iterations for MDS. Defaults to 500.</p> <code>500</code> <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p>"},{"location":"reference/geometry/#protstruc.geometry.place_fourth_atom","title":"<code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>","text":"<p>Place a fourth atom X given three atoms (A, B and C) and the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.array</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>np.array</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>np.array</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>length</code> <code>np.array</code> <p>Length of the bond between atom c and the new atom (shape: (n, 1)) i.e., bond length CX</p> required <code>planar</code> <code>np.array</code> <p>Planar angle between the new atom and the bond between atom c and the new atom (shape: (n, 1)) i.e., angle XCB</p> required <code>dihedral</code> <code>np.array</code> <p>Dihedral angle between the new atom and the plane defined by atoms a, b, and c (shape: (n, 1)) i.e., dihedral angle between planes XCB and ACB</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>3D coordinates of the new atom X (shape: (n, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.reconstruct_backbone_distmat_from_interresidue_geometry","title":"<code>reconstruct_backbone_distmat_from_interresidue_geometry(d_cb, omega, theta, phi, mask=None, chain_breaks=None)</code>","text":"<p>Reconstruct the backbone distance matrix from interresidue geometry including Cb distance matrix (<code>d_cb</code>), Ca-Cb-Ca'-Cb' dihedral (<code>omega</code>), N-Ca-Cb-Cb' dihedral (<code>theta</code>), and Ca-Cb-Cb' planar angle (<code>phi</code>).</p> <p>Parameters:</p> Name Type Description Default <code>d_cb</code> <code>np.array</code> <p>Cb distance matrix (shape: (L, L))</p> required <code>omega</code> <code>np.array</code> <p>Ca-Cb-Ca'-Cb' dihedral matrix (shape: (L, L))</p> required <code>theta</code> <code>np.array</code> <p>N-Ca-Cb-Cb' dihedral matrix (shape: (L, L))</p> required <code>phi</code> <code>np.array</code> <p>Ca-Cb-Cb' planar angle matrix (shape: (L, L))</p> required <code>mask</code> <code>np.array</code> <p>Mask for valid residue pairs, i.e., pairs of residues whose distance can be reconstructed from interresidue geometry (shape: (L, L))</p> <code>None</code> <code>chain_breaks</code> <code>list</code> <p>List of chain breaks, i.e., indices of residues that are not in the same chain with the next one.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.array</code> <p>Backbone distance matrix representing the distance between N, Ca, C atoms between residues (shape: (3, 3, L, L))</p>"},{"location":"reference/io/","title":"protstruc.io","text":""},{"location":"reference/io/#protstruc.io.infill_chain_idx","title":"<code>infill_chain_idx(chain_idx)</code>","text":"<p>Infill the chain index tensor to fill in the gaps.</p>"},{"location":"reference/io/#protstruc.io.pdb_to_xyz","title":"<code>pdb_to_xyz(filename)</code>","text":"<p>Parse a PDB file and return a tensor containing 3D coordinates of atoms.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to a PDB file.</p> required <p>Returns:</p> Name Type Description <code>atom_xyz</code> <code>torch.Tensor</code> <p>A xyz coordinate tensor. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE, 3).</p> <code>atom_mask</code> <code>torch.BoolTensor</code> <p>A mask tensor. 1 if the corresponding atom exists, 0 otherwise. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE)</p> <code>chain_idx</code> <code>torch.LongTensor</code> <p>A LongTensor containing chain indices per residue. Shape (n_residues,)</p> <code>chain_ids</code> <code>List[str]</code> <p>A list of unique chain IDs in the order of integers appearing in the <code>chain_idx</code> tensor.</p> <code>seq</code> <code>Dict[str, str]</code> <p>A dictionary mapping chain IDs to amino acid sequences.</p> Note <p><code>MAX_N_ATOMS_PER_RESIDUE</code> is set to 15 by default.</p>"},{"location":"reference/io/#protstruc.io.to_pdb","title":"<code>to_pdb(filename, coords, sequences, chain_ids, atoms=['N', 'CA', 'C', 'O', 'CB'])</code>","text":"<p>Save coordinates to a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output PDB file.</p> required <code>coords</code> <code>np.array</code> <p>Coordinates of shape (5, L, 3), where the first dimension denotes the atom type.</p> required <code>atoms</code> <code>List</code> <p>Defaults to [\"N\", \"CA\", \"C\", \"O\", \"CB\"].</p> <code>['N', 'CA', 'C', 'O', 'CB']</code>"},{"location":"reference/protstruc/","title":"protstruc.protstruc","text":""},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch","title":"<code>StructureBatch</code>","text":"<p>A batch of protein structures.</p> <p>This class provides an interface to initialize from and represent a batch of protein structures with various types of representations:</p> StructureBatch object can be initialized with <ul> <li>A single PDB file or a list of PDB files <code>StructureBatch.from_pdb</code></li> <li>A pdb identifier or a list of PDB identifiers <code>StructureBatch.from_pdb_id</code> (TODO)</li> <li>Backbone or full atom 3D coordinates <code>StructureBatch.from_xyz</code></li> <li>Dihedral angles <code>StructureBatch.from_dihedrals</code> (TODO)</li> </ul>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_xyz","title":"<code>from_xyz(xyz, atom_mask=None, chain_idx=None, chain_ids=None, seq=None)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a 3D coordinate array.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a numpy array of atom 3D coordinates.</p> <pre><code>&gt;&gt;&gt; batch_size, n_max_res, n_max_atoms = 2, 10, 25\n&gt;&gt;&gt; xyz = np.random.randn(batch_size, n_max_res, n_max_atoms, 3)\n&gt;&gt;&gt; sb = StructureBatch.from_xyz(xyz)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms, 3)</p> required <code>atom_mask</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms)</p> <code>None</code> <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain indices for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code> <code>seq</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_pdb","title":"<code>from_pdb(pdb_path)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB file or a list of PDB files.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a single PDB file,</p> <pre><code>&gt;&gt;&gt; pdb_path = '1a0a.pdb'\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_path)\n</code></pre> <p>or with a list of PDB files.</p> <pre><code>&gt;&gt;&gt; pdb_paths = ['1a0a.pdb', '1a0b.pdb']\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_paths)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_path</code> <code>Union[str, List[str]]</code> <p>Path to a PDB file or a list of paths to PDB files.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_pdb_id","title":"<code>from_pdb_id(pdb_id)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB ID or a list of PDB IDs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pdb_id = \"2ZIL\"  # Human lysozyme\n&gt;&gt;&gt; sb = StructureBatch.from_pdb_id(pdb_id)\n&gt;&gt;&gt; xyz = sb.get_xyz()\n&gt;&gt;&gt; xyz.shape\ntorch.Size([1, 130, 15, 3])\n&gt;&gt;&gt; dihedrals, dihedral_mask = sb.backbone_dihedrals()\n&gt;&gt;&gt; dihedrals.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.sum()\ntensor(3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_id</code> <code>Union[str, List[str]]</code> <p>A PDB identifier or a list of PDB identifiers.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.from_dihedrals","title":"<code>from_dihedrals(dihedrals, chain_idx=None, chain_ids=None)</code>  <code>classmethod</code>","text":"<p>Initialize a StructureBatch from a dihedral angle array.</p> <p>Parameters:</p> Name Type Description Default <code>dihedrals</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_dihedrals)</p> required <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain identifiers for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_seq","title":"<code>get_seq()</code>","text":"<p>Return the amino acid sequence of proteins.</p> <p>Returns:</p> Name Type Description <code>seq_dict</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_total_lengths","title":"<code>get_total_lengths()</code>","text":"<p>Return the total sum of chain lengths for each protein.</p> Note <p>This counts the number of missing residues in the middle of a chain, but does not count the missing residues at the beginning and end of a chain.</p> <p>Returns:</p> Name Type Description <code>total_lengths</code> <code>torch.LongTensor</code> <p>A tensor containing the total length of each protein. Shape: (batch_size,)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_n_terminal_mask","title":"<code>get_n_terminal_mask()</code>","text":"<p>Return a boolean mask for the N-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting N-terminal residues. <code>True</code> if N-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.get_c_terminal_mask","title":"<code>get_c_terminal_mask()</code>","text":"<p>Return a boolean mask for the C-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting C-terminal residues. <code>True</code> if C-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.pairwise_distance_matrix","title":"<code>pairwise_distance_matrix()</code>","text":"<p>Return the all-atom pairwise pairwise distance matrix between residues.</p> Info <p>Distances are measured in Angstroms.</p> <p>Examples:</p> <p><code>dist[:, :, 1, 1]</code> will give pairwise alpha-carbon distance matrix between residues, as the index <code>1</code> corresponds to the alpha-carbon atom. <pre><code>&gt;&gt;&gt; structure_batch = StructureBatch.from_pdb(\"1a8o.pdb\")\n&gt;&gt;&gt; dist = structure_batch.pairwise_distance_matrix()\n&gt;&gt;&gt; ca_dist = dist[:, :, 1, 1]  # 1 = CA_IDX\n</code></pre></p> <p>Returns:</p> Name Type Description <code>dist</code> <code>torch.FloatTensor</code> <p>A tensor containing an all-atom pairwise distance matrix for each pair of residues. A distance between atom <code>a</code> of residue <code>i</code> and atom <code>b</code> of residue <code>j</code> is given by <code>dist[i, j, a, b]</code>. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p> <code>dist_mask</code> <code>torch.BoolTensor</code> <p>A boolean tensor denoting which distances are valid. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_dihedrals","title":"<code>backbone_dihedrals()</code>","text":"<p>Return the backbone dihedral angles phi, psi and omega for each residue.</p> Info <p>Dihedral angles are measured in radians and are in the range <code>[-pi, pi]</code>.</p> <p>For a quick reminder of the definition of the dihedral angles, refer to the following image: </p> <p>Source: Fabian Fuchs</p> Note <p><code>phi</code> angles are not defined for the first residue (it needs a predecessor) and <code>psi</code> and <code>omega</code> angles are not defined for the last residue (they need successors). Those invalid angles can be filtered using the <code>dihedral_mask</code> tensor returned from the method.</p> Warning <p>Dihedral angles involving the residues at the chain breaks are not handled correctly for now.</p> <p>Returns:</p> Name Type Description <code>dihedrals</code> <code>torch.FloatTensor</code> <p>A tensor containing <code>phi</code>, <code>psi</code> and <code>omega</code> dihedral angles for each residue. Shape: (batch_size, num_residues, 3)</p> <code>dihedral_mask</code> <code>torch.FloatTensor</code> <p>A tensor containing a boolean mask for the dihedral angles. <code>True</code> if the corresponding dihedral angle is defined, <code>False</code> otherwise. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_orientations","title":"<code>backbone_orientations(a1='N', a2='CA', a3='C')</code>","text":"<p>Return the orientation of the backbone for each residue.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>str</code> <p>First atom used to determine backbone orientation. Defaults to 'N'.</p> <code>'N'</code> <code>a2</code> <code>str</code> <p>Second atom used to determine backbone orientation. Defaults to 'CA'.</p> <code>'CA'</code> <code>a3</code> <code>str</code> <p>Third atom used to determine backbone orientation. Defaults to 'C'.</p> <code>'C'</code> Note <p>The backbone orientations are determined by using Gram-Schmidt orthogonalization on the vectors formed by the atoms <code>a1</code>, <code>a2</code> and <code>a3</code>.</p> <p>Returns:</p> Name Type Description <code>bb_orientations</code> <code>torch.FloatTensor</code> <p>A tensor containing the local reference backbone orientation for each residue.</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.backbone_translations","title":"<code>backbone_translations(atom='CA')</code>","text":"<p>Return the coordinate (translation) of a given backbone atom for each residue.</p> Note <p>Reference atom is set to the alpha-carbon (CA) by default.</p> <p>Parameters:</p> Name Type Description Default <code>atom</code> <code>str</code> <p>Type of atom used to determine backbone translation. Defaults to 'CA'.</p> <code>'CA'</code> <p>Returns:</p> Name Type Description <code>bb_translations</code> <code>torch.FloatTensor</code> <p>xyz coordinates (translations) of a specified backbone atoms. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.StructureBatch.inter_residue_dihedrals","title":"<code>inter_residue_dihedrals(use_cb=False)</code>","text":"<p>Return the inter-residue dihedral angles.</p> <p>Parameters:</p> Name Type Description Default <code>use_cb</code> <code>bool</code> <p>Use CB atom instead of CA. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Shape</code> <p>(batch_size, num_residues, num_residues, 2)</p>"},{"location":"reference/protstruc/#protstruc.protstruc.AntibodyFvStructure","title":"<code>AntibodyFvStructure</code>","text":""},{"location":"reference/protstruc/#protstruc.protstruc.AntibodyFvStructure.inter_residue_geometry","title":"<code>inter_residue_geometry(to_degree=False)</code>","text":"<p>https://github.com/RosettaCommons/RoseTTAFold/blob/main/network/kinematics.py</p>"},{"location":"tutorials/backbone_orientations_and_translations/","title":"Backbone orientations/translations","text":"In\u00a0[2]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\n</pre> import protstruc as ps import matplotlib.pyplot as plt <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[3]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) In\u00a0[4]: Copied! <pre>orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C')\ntranslations = sb.backbone_translations(atom='CA')\n\norientations.shape, translations.shape\n</pre> orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C') translations = sb.backbone_translations(atom='CA')  orientations.shape, translations.shape Out[4]: <pre>(torch.Size([2, 184, 3, 3]), torch.Size([2, 184, 3]))</pre> In\u00a0[5]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# plot backbone CA atoms \nax.scatter(\n    translations[0, :, 0],\n    translations[0, :, 1],\n    translations[0, :, 2],\n)\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  # plot backbone CA atoms  ax.scatter(     translations[0, :, 0],     translations[0, :, 1],     translations[0, :, 2], )"},{"location":"tutorials/pairwise_distance_matrix/","title":"Pairwise distance matrix","text":"In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\n\nfrom protstruc.general import ATOM, AA\nfrom biopandas.pdb import PandasPdb\n</pre> import protstruc as ps import matplotlib.pyplot as plt  from protstruc.general import ATOM, AA from biopandas.pdb import PandasPdb <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <p>Initialize a <code>StructureBatch</code> instance from a PDB IDs.</p> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\ndistmat, distmat_mask = sb.pairwise_distance_matrix()\n\ndistmat.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) distmat, distmat_mask = sb.pairwise_distance_matrix()  distmat.shape Out[2]: <pre>torch.Size([2, 184, 184, 15, 15])</pre> <p>Compute total number of residues for each protein.</p> In\u00a0[3]: Copied! <pre>total_lengths = sb.get_total_lengths()\ntotal_lengths\n</pre> total_lengths = sb.get_total_lengths() total_lengths Out[3]: <pre>tensor([130, 184])</pre> In\u00a0[4]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])     ax.set_title(pdb_ids[i]) In\u00a0[5]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])      ax.set_title(pdb_ids[i])"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-ca-atoms","title":"Pairwise distance matrix between Ca atoms\u00b6","text":"<p>Note that 4EOT has 2 chains, so the pairwise distance matrix shows horizontal and vertical split.</p>"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-cb-atoms","title":"Pairwise distance matrix between Cb atoms\u00b6","text":"<p>Note that glycine residue does not have $C_{\\beta}$ atom and thus the distance from/to glycine residue is not defined.</p>"},{"location":"tutorials/ramachandran_plot/","title":"Ramachandran plot","text":"In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import protstruc as ps import matplotlib.pyplot as plt import numpy as np <pre>/data/project/dohoon/miniconda3/envs/torch12/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n\ndihedrals, dihedral_mask = sb.backbone_dihedrals()\ndihedrals.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids)  dihedrals, dihedral_mask = sb.backbone_dihedrals() dihedrals.shape Out[2]: <pre>torch.Size([2, 184, 3])</pre> In\u00a0[4]: Copied! <pre>PHI_IDX, PSI_IDX = 0, 1\nfig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\nplt.subplots_adjust(wspace=0.3)\n</pre> PHI_IDX, PSI_IDX = 0, 1 fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')      ax = fig.add_subplot(1, 2, i+1)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])  plt.subplots_adjust(wspace=0.3) <pre>1REX has 128 residues valid for phi/psi plot.\n4EOT has 180 residues valid for phi/psi plot.\n</pre> In\u00a0[5]: Copied! <pre>import biotite.structure as struc\nfrom biotite.structure.io.pdb import PDBFile\nfrom biotite.database.rcsb import fetch\nfetch(pdb_ids, 'pdb', '.')\n</pre> import biotite.structure as struc from biotite.structure.io.pdb import PDBFile from biotite.database.rcsb import fetch fetch(pdb_ids, 'pdb', '.') Out[5]: <pre>['./1REX.pdb', './4EOT.pdb']</pre> In\u00a0[15]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\n    n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()\n    print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])      n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()     print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot') plt.subplots_adjust(wspace=0.3)  <pre>1REX has 128 residues valid for phi/psi plot\n4EOT has 180 residues valid for phi/psi plot\n</pre> In\u00a0[19]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(phi, my_phi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('phi (biotite)')\n    ax.set_ylabel('phi (ProtStruc)')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(phi, my_phi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('phi (biotite)')     ax.set_ylabel('phi (ProtStruc)') plt.subplots_adjust(wspace=0.3)  In\u00a0[18]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(psi, my_psi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('psi (biotite)')\n    ax.set_ylabel('psi (ProtStruc)')\n\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(psi, my_psi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('psi (biotite)')     ax.set_ylabel('psi (ProtStruc)')  plt.subplots_adjust(wspace=0.3)"},{"location":"tutorials/ramachandran_plot/#compute-backbone-dihedrals-using-backbone_dihedrals","title":"Compute backbone dihedrals using <code>backbone_dihedrals()</code>\u00b6","text":"<p><code>backbone_dihedrals()</code> computes backbone dihedrals of a given protein structure and returns a tensor of shape <code>(B, L, 3)</code> where B is the batch size and L is the length of the protein. The last dimension denotes the three backbone dihedrals $\\phi$, $\\psi$ and $\\omega$.</p>"},{"location":"tutorials/ramachandran_plot/#ramachandran-plots","title":"Ramachandran plots\u00b6","text":"<p>Now plotting a Ramachandran plot is straightforward.</p> <p>We can see that protein <code>4EOT</code> is mainly composed of alpha helices.</p>"},{"location":"tutorials/ramachandran_plot/#benchmarking-with-biotitestructure","title":"Benchmarking with <code>biotite.structure</code>\u00b6","text":""}]}