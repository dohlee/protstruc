{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProtStruc","text":""},{"location":"#what-is-protstruc","title":"What is ProtStruc?","text":"<p>ProtStruc is a Python package for handling protein structures, especially for deep learning applications, through a simple, flexible, and efficient representation of protein structures.</p> <p>There are many ways to represent protein structures in various deep learning applications:</p> Year &amp; Source Category Deep learning application Protein structure representation 2020, PNAS Structure prediction TrRoseTTA Inter-residue geometry 2021, Science Structure prediction RoseTTAFold Inter-residue geometry 2021, Nature Structure prediction AlphaFold2 Orientation &amp; translation of backbone frames centered at Ca's 2022, Patterns Structure prediction DeepAb Inter-residue geometry 2023, Nat. Commun. Antibody structure prediction IgFold Oritentation &amp; translation of backbone frames centered at Ca's 2022, arXiv Structure generation FoldingDiff Three backbone dihedrals and three bond angles 2022, NeurIPS Structure generation DiffAb Orientation &amp; translation of backbone frames centered at Ca's 2022, Science Inverse-folding ProteinMPNN k-nearest neighbor graph 2022, arXiv Inverse-folding PiFold Inter-atomic/residue distance, backbone dihedrals and bond angles, orientation of residue frame, inter-residue orientations 2023, Science Structure prediction ESMFold Orientation &amp; translation of backbone frames centered at Ca's 2023, ICML Structure generation FrameDiff Orientation &amp; translation of backbone frames centered at Ca's, an additional torsion angle for oxygen atom 2022, ICML Structure generation Hierarchical Equivariant Refinement Network (HERN) 2022, arXiv Sequence-structure co-design Multi-channel Equivariant Attention Network (MEAN) 2023, ICML Sequence-structure co-design Dynamic multi-channel Equivariant Attention Network (dyMEAN)"},{"location":"getting-started/installation/","title":"Installation","text":"<p>ProtStruc is available on PyPI and can be installed with pip.</p> <pre><code>$ pip install protstruc\n</code></pre>"},{"location":"getting-started/installation/#testing","title":"Testing","text":"<p>Once you have installed ProtStruc, you can test your installation by running the following command:</p> <pre><code>$ pytest </code></pre>"},{"location":"home/examples/","title":"Examples","text":""},{"location":"home/examples/#initialize-a-single-protein-structure-from-a-pdb-file","title":"Initialize a single protein structure from a PDB file","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_file = '1a0s.pdb'\nbatch = ps.StructureBatch.from_pdb(pdb_file)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-a-list-of-pdb-files","title":"Initialize a batch of protein structures from a list of PDB files","text":"<pre><code>import torch\nimport protstruc as ps\n\npdb_files = ['1a0s.pdb', '1a1s.pdb', '1a2s.pdb', '1a3s.pdb', '1a4s.pdb']\nbatch = ps.StructureBatch.from_pdb(pdb_files)\n</code></pre>"},{"location":"home/examples/#initialize-a-batch-of-protein-structures-from-backbone-or-full-atom-xyz-coordinates","title":"Initialize a batch of protein structures from backbone (or full atom) xyz coordinates","text":"<pre><code>import torch\nimport protstruc as ps\n\nbatch_size, max_n_residues = 32, 100\nmax_n_atoms_per_residue = 10\n\nxyz = torch.randn(batch_size, max_n_residues, max_n_atoms_per_residue, 3)\n\nbatch = ps.StructureBatch.from_xyz(xyz)\n</code></pre>"},{"location":"reference/AntibodyStructureBatch/","title":"AntibodyStructureBatch","text":"<p>             Bases: <code>StructureBatch</code></p>"},{"location":"reference/AntibodyStructureBatch/#protstruc.protstruc.AntibodyStructureBatch.from_pdb","title":"<code>from_pdb(pdb_path, heavy_chain_id=None, light_chain_id=None, antigen_chain_ids=None, numbering_scheme='chothia', keep_fv_only=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize an <code>AntibodyStructureBatch</code> from a PDB file or a list of PDB files.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a single PDB file,</p> <pre><code>&gt;&gt;&gt; pdb_path = '1a0a.pdb'\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_path)\n</code></pre> <p>or with a list of PDB files.</p> <pre><code>&gt;&gt;&gt; pdb_paths = ['1a0a.pdb', '1a0b.pdb']\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_paths)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_path</code> <code>Union[str, List[str]]</code> <p>Path to a PDB file or a list of paths to PDB files.</p> required <code>heavy_chain_id</code> <code>List[str]</code> <p>Chain ID of the heavy chain.</p> <code>None</code> <code>light_chain_id</code> <code>List[str]</code> <p>Chain ID of the light chain.</p> <code>None</code> <code>antigen_chain_ids</code> <code>List[List[str]]</code> <p>Chain IDs of the antigen chains. Defaults to None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AntibodyStructureBatch</code> <code>AntibodyStructureBatch</code> <p>An AntibodyStructureBatch object.</p>"},{"location":"reference/StructureBatch/","title":"StructureBatch","text":"<p>A batch of protein structures.</p> <p>This class provides an interface to initialize from and represent a batch of protein structures with various types of representations:</p> StructureBatch object can be initialized with <ul> <li>A single PDB file or a list of PDB files <code>StructureBatch.from_pdb</code></li> <li>A pdb identifier or a list of PDB identifiers <code>StructureBatch.from_pdb_id</code></li> <li>Backbone or full atom 3D coordinates <code>StructureBatch.from_xyz</code></li> <li>Backbone orientation and translations <code>StructureBatch.from_backbone_orientations_translations</code></li> <li>Dihedral angles <code>StructureBatch.from_dihedrals</code> (TODO)</li> </ul>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.from_xyz","title":"<code>from_xyz(xyz, atom_mask=None, chain_idx=None, chain_ids=None, seq=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a 3D atom coordinate array.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a numpy array of 3D atom coordinates.</p> <pre><code>&gt;&gt;&gt; batch_size, n_max_res, n_max_atoms = 2, 10, 25\n&gt;&gt;&gt; xyz = np.random.randn(batch_size, n_max_res, n_max_atoms, 3)\n&gt;&gt;&gt; sb = StructureBatch.from_xyz(xyz)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms, 3)</p> required <code>atom_mask</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_atoms)</p> <code>None</code> <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain indices for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code> <code>seq</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.from_pdb","title":"<code>from_pdb(pdb_path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB file or a list of PDB files.</p> <p>Examples:</p> <p>Initialize a <code>StructureBatch</code> object from a single PDB file,</p> <pre><code>&gt;&gt;&gt; pdb_path = '1a0a.pdb'\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_path)\n</code></pre> <p>or with a list of PDB files.</p> <pre><code>&gt;&gt;&gt; pdb_paths = ['1a0a.pdb', '1a0b.pdb']\n&gt;&gt;&gt; sb = StructureBatch.from_pdb(pdb_paths)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_path</code> <code>Union[str, List[str]]</code> <p>Path to a PDB file or a list of paths to PDB files.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.from_pdb_id","title":"<code>from_pdb_id(pdb_id, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>StructureBatch</code> from a PDB ID or a list of PDB IDs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pdb_id = \"2ZIL\"  # Human lysozyme\n&gt;&gt;&gt; sb = StructureBatch.from_pdb_id(pdb_id)\n&gt;&gt;&gt; xyz = sb.get_xyz()\n&gt;&gt;&gt; xyz.shape\ntorch.Size([1, 130, 15, 3])\n&gt;&gt;&gt; dihedrals, dihedral_mask = sb.backbone_dihedrals()\n&gt;&gt;&gt; dihedrals.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.shape\ntorch.Size([1, 130, 3])\n&gt;&gt;&gt; dihedral_mask.sum()\ntensor(3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pdb_id</code> <code>Union[str, List[str]]</code> <p>A PDB identifier or a list of PDB identifiers.</p> required <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.from_backbone_orientations_translations","title":"<code>from_backbone_orientations_translations(orientations, translations, chain_idx=None, chain_ids=None, seq=None, include_cb=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a StructureBatch from an array of backbone orientations and translations.</p> <p>Parameters:</p> Name Type Description Default <code>orientations</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, 3, 3)</p> required <code>translations</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, 3)</p> required <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain identifiers for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code> <code>seq</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p> <code>None</code> <code>include_cb</code> <code>bool</code> <p>Whether to include CB atoms when initializing. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>StructureBatch</code> <code>StructureBatch</code> <p>A StructureBatch object.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.from_dihedrals","title":"<code>from_dihedrals(dihedrals, chain_idx=None, chain_ids=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a StructureBatch from a dihedral angle array.</p> <p>Parameters:</p> Name Type Description Default <code>dihedrals</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Shape: (batch_size, num_residues, num_dihedrals)</p> required <code>chain_idx</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>Chain identifiers for each residue. Should be starting from zero. Defaults to None. Shape: (batch_size, num_residues)</p> <code>None</code> <code>chain_ids</code> <code>List[List[str]]</code> <p>A list of unique chain IDs for each protein.</p> <code>None</code>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_local_xyz","title":"<code>get_local_xyz()</code>","text":"<p>Return the coordinates of each atom in the local frame of each residue.</p> <p>Returns:</p> Name Type Description <code>local_xyz</code> <code>torch.Tensor</code> <p>Shape: (batch_size, num_residues, num_atoms_per_residue, 3)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_atom_mask","title":"<code>get_atom_mask()</code>","text":"<p>Return a boolean mask for valid atoms.</p> <p>Returns:</p> Name Type Description <code>atom_mask</code> <code>torch.BoolTensor</code> <p>Shape (batch_size, num_residues, num_atoms)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_residue_mask","title":"<code>get_residue_mask()</code>","text":"<p>Return a boolean mask for valid residues.</p> <p>Returns:</p> Name Type Description <code>residue_mask</code> <code>torch.BoolTensor</code> <p>Shape (batch_size, num_residues)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_seq","title":"<code>get_seq()</code>","text":"<p>Return the amino acid sequence of proteins.</p> <p>Returns:</p> Name Type Description <code>seq_dict</code> <code>List[Dict[str, str]]</code> <p>A list of dictionaries containing sequence information for each chain.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_seq_idx","title":"<code>get_seq_idx()</code>","text":"<p>Return a tensor containing the integer representation of amino acid sequence of proteins.</p> <p>Returns:</p> Name Type Description <code>seq_idx</code> <code>torch.LongTensor</code> <p>A tensor containing the integer representation of amino acid sequence of proteins.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_total_lengths","title":"<code>get_total_lengths()</code>","text":"<p>Return the total sum of chain lengths for each protein.</p> Note <p>This counts the number of missing residues in the middle of a chain, but does not count the missing residues at the beginning and end of a chain.</p> <p>Returns:</p> Name Type Description <code>total_lengths</code> <code>torch.LongTensor</code> <p>A tensor containing the total length of each protein. Shape: (batch_size,)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_max_n_residues","title":"<code>get_max_n_residues()</code>","text":"<p>Return the number of residues in the longest protein in the batch.</p> <p>Returns:</p> Name Type Description <code>max_n_residues</code> <code>int</code> <p>The number of residues in the longest protein in the batch.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_n_terminal_mask","title":"<code>get_n_terminal_mask()</code>","text":"<p>Return a boolean mask for the N-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting N-terminal residues. <code>True</code> if N-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.get_c_terminal_mask","title":"<code>get_c_terminal_mask()</code>","text":"<p>Return a boolean mask for the C-terminal residues.</p> <p>Returns:</p> Type Description <code>torch.BoolTensor</code> <p>A boolean tensor denoting C-terminal residues. <code>True</code> if C-terminal. Shape: (batch_size, num_residues)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.pairwise_distance_matrix","title":"<code>pairwise_distance_matrix()</code>","text":"<p>Return the all-atom pairwise pairwise distance matrix between residues.</p> Info <p>Distances are measured in Angstroms.</p> <p>Examples:</p> <p><code>dist[:, :, :, 1, 1]</code> will give pairwise alpha-carbon distance matrix between residues, as the index <code>1</code> corresponds to the alpha-carbon atom. <pre><code>&gt;&gt;&gt; structure_batch = StructureBatch.from_pdb(\"1a8o.pdb\")\n&gt;&gt;&gt; dist = structure_batch.pairwise_distance_matrix()\n&gt;&gt;&gt; ca_dist = dist[:, :, :, 1, 1]  # 1 = CA_IDX\n</code></pre></p> <p>Returns:</p> Name Type Description <code>dist</code> <code>torch.FloatTensor</code> <p>A tensor containing an all-atom pairwise distance matrix for each pair of residues. A distance between atom <code>a</code> of residue <code>i</code> and atom <code>b</code> of residue <code>j</code> of protein at index <code>batch_idx</code> is given by <code>dist[batch_idx, i, j, a, b]</code>. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p> <code>dist_mask</code> <code>torch.BoolTensor</code> <p>A boolean tensor denoting which distances are valid. Shape: (batch_size, num_residues, num_residues, max_n_atoms_per_residue, max_n_atoms_per_residue)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.backbone_dihedrals","title":"<code>backbone_dihedrals()</code>","text":"<p>Return the backbone dihedral angles phi, psi and omega for each residue.</p> Info <p>Dihedral angles are measured in radians and are in the range <code>[-pi, pi]</code>.</p> <p>For a quick reminder of the definition of the dihedral angles, refer to the following image: </p> <p>Source: Fabian Fuchs</p> Note <p><code>phi</code> angles are not defined for the first residue (it needs a predecessor) and <code>psi</code> and <code>omega</code> angles are not defined for the last residue (they need successors). Those invalid angles can be filtered using the <code>dihedral_mask</code> tensor returned from the method.</p> Warning <p>Dihedral angles involving the residues at the chain breaks are not handled correctly for now.</p> <p>Returns:</p> Name Type Description <code>dihedrals</code> <code>torch.FloatTensor</code> <p>A tensor containing <code>phi</code>, <code>psi</code> and <code>omega</code> dihedral angles for each residue. Shape: (batch_size, num_residues, 3)</p> <code>dihedral_mask</code> <code>torch.FloatTensor</code> <p>A tensor containing a boolean mask for the dihedral angles. <code>True</code> if the corresponding dihedral angle is defined, <code>False</code> otherwise. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.backbone_orientations","title":"<code>backbone_orientations(a1='N', a2='CA', a3='C')</code>","text":"<p>Return the orientation of the backbone for each residue.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>str</code> <p>First atom used to determine backbone orientation. Defaults to 'N'.</p> <code>'N'</code> <code>a2</code> <code>str</code> <p>Second atom used to determine backbone orientation. Defaults to 'CA'.</p> <code>'CA'</code> <code>a3</code> <code>str</code> <p>Third atom used to determine backbone orientation. Defaults to 'C'.</p> <code>'C'</code> Note <p>The backbone orientations are determined by using Gram-Schmidt orthogonalization on the vectors <code>a3 - a2</code> and <code>a1 - a2</code>. Note that <code>a3 - a2</code> forms the first basis, and <code>a1 - a2</code> - proj_{a3 - a2}(a1 - a2) forms the second basis. The third basis is formed by taking the cross product of the first and second basis vectors.</p> <p>Returns:</p> Name Type Description <code>bb_orientations</code> <code>torch.FloatTensor</code> <p>A tensor containing the local reference backbone orientation for each residue.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.backbone_translations","title":"<code>backbone_translations(atom='CA')</code>","text":"<p>Return the coordinate (translation) of a given backbone atom for each residue.</p> Note <p>Reference atom is set to the alpha-carbon (CA) by default.</p> <p>Parameters:</p> Name Type Description Default <code>atom</code> <code>str</code> <p>Type of atom used to determine backbone translation. Defaults to 'CA'.</p> <code>'CA'</code> <p>Returns:</p> Name Type Description <code>bb_translations</code> <code>torch.FloatTensor</code> <p>xyz coordinates (translations) of a specified backbone atoms. Shape: (batch_size, num_residues, 3)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.pairwise_dihedrals","title":"<code>pairwise_dihedrals(atoms_i, atoms_j)</code>","text":"<p>Return a matrix representing a pairwise dihedral angle between residues defined by two sets of atoms, one for each side of the residue.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_i</code> <code>List[str]</code> <p>List of atoms to be used for the first residue.</p> required <code>atoms_j</code> <code>List[str]</code> <p>List of atoms to be used for the second residue.</p> required <p>Returns:</p> Name Type Description <code>pairwise_dihedrals</code> <code>torch.FloatTensor</code> <p>A tensor containing pairwise dihedral angles between residues. Shape: (batch_size, num_residues, num_residues)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.pairwise_planar_angles","title":"<code>pairwise_planar_angles(atoms_i, atoms_j)</code>","text":"<p>Return a matrix representing a pairwise planar angles between residues defined by two sets of atoms, one for each side of the residue.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_i</code> <code>List[str]</code> <p>List of atoms to be used for the first residue.</p> required <code>atoms_j</code> <code>List[str]</code> <p>List of atoms to be used for the second residue.</p> required <p>Returns:</p> Name Type Description <code>pairwise_planar_angles</code> <code>torch.FloatTensor</code> <p>A tensor containing pairwise planar angles between residues. Shape: (batch_size, num_residues, num_residues)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.translate","title":"<code>translate(translation, atomwise=False)</code>","text":"<p>Translate the structures by a given tensor of shape (batch_size, num_residues, 3) or (batch_size, 1, 3). Translation is performed residue-wise by default, but atomwise translation can be performed when <code>atomwise=True</code>. In that case, the translation tensor should have a shape of (batch_size, num_residues, num_atom, 3).</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>torch.Tensor</code> <p>Translation vector. Shape: (batch_size, num_residues, 3) if <code>atomwise=False</code>, (batch_size, num_residues, num_atom, 3) otherwise.</p> required"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.rotate","title":"<code>rotate(rotation)</code>","text":"<p>Rotate the structures by a given rotation matrix of shape (batch_size, 3, 3).</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>torch.Tensor</code> <p>Rotation matrix. Shape: (batch_size, 3, 3) if rotations is applied structure-by-structure, (3, 3) if the same rotation is to be applied to all structures.</p> required"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.standardize","title":"<code>standardize(atom_mask=None, residue_mask=None)</code>","text":"<p>Standardize the coordinates of the structures to have zero mean and unit standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>atom_mask</code> <code>bool</code> <p>Mask for atoms used for standardization. If None, all atoms are used. <code>atom_mask</code> and <code>residue_mask</code> cannot be specified at the same time. Shape: (batch_size, num_residues, num_atoms)</p> <code>None</code> <code>residue_mask</code> <code>bool</code> <p>Mask for residues used for standardization. If None, all residues are used. <code>atom_mask</code> and <code>residue_mask</code> cannot be specified at the same time. Shape: (batch_size, num_residues)</p> <code>None</code>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.unstandardize","title":"<code>unstandardize()</code>","text":"<p>Recover the coordinates at original scale from the standardized coordinates.</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.center_of_mass","title":"<code>center_of_mass()</code>","text":"<p>Compute the center of mass of the structures.</p> Warning <p>Only Ca atoms are considered when computing the coordinates of center of mass.</p> <p>Returns:</p> Name Type Description <code>center_of_mass</code> <code>torch.Tensor</code> <p>A tensor containing the center of mass of the structures. Shape: (batch_size, 3)</p>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.center_at","title":"<code>center_at(center=None)</code>","text":"<p>Translate the whole structure so that the center of Ca atom coordinates is at the given 3D coordinates. If <code>center</code> is not specified, the structures (considering only Ca coordinates) are centered at the origin.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>torch.Tensor</code> <p>Coordinates of the center. Shape: (batch_size, 3) or (3,)</p> <code>None</code>"},{"location":"reference/StructureBatch/#protstruc.protstruc.StructureBatch.inter_residue_geometry","title":"<code>inter_residue_geometry()</code>","text":"<p>Return a dictionary of inter-residue geometry, which is used for representing protein structure for trRoseTTA.</p> <p>Returns:</p> Name Type Description <code>inter_residue_geometry</code> <code>Dict[str, torch.Tensor]</code> <p>A dictionary containing inter-residue geometry tensors.</p>"},{"location":"reference/geometry/","title":"geometry","text":"<p>Utility functions for computing 3D geometry of protein structures.</p> <p>This module contains the following functions:</p> <ul> <li><code>angle(a, b, c, to_degree=False)</code>: Compute planar angles between three points.</li> <li><code>dihedral(a, b, c, d, to_degree=False)</code>: Compute dihedral angle between four points.</li> <li><code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>: Place a fourth atom X given three atoms (A, B and C) and     the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</li> </ul>"},{"location":"reference/geometry/#protstruc.geometry.angle","title":"<code>angle(a, b, c, to_degree=False)</code>","text":"<p>Compute planar angles (0 ~ pi) between three (array of) points a, b and c.</p> Note <p>The planar angle is computed as the angle between the vectors <code>ab</code> and <code>bc</code> using the dot product followed by <code>torch.arccos</code>. If <code>to_degree</code> is False, the output is in radians between 0 and pi. Otherwise, the output is in degrees between 0 and 180.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a. Shape: (n, 3)</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b. Shape: (n, 3)</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c. Shape: (n, 3)</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return angles in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Planar angle between three points. Shape: (n,)</p>"},{"location":"reference/geometry/#protstruc.geometry.dihedral","title":"<code>dihedral(a, b, c, d, to_degree=False)</code>","text":"<p>Compute dihedral angle (-pi ~ pi) between (array of) four points a, b, c and d.</p> Note <p>The dihedral angle is the angle in the clockwise direction of the fourth atom compared to the first atom, while looking down the axis of the second to the third.</p> <p>The dihedral angle is computed as the angle between the plane defined by vectors <code>ba</code> and <code>bc</code> and the plane defined by vectors <code>bc</code> and <code>cd</code>. In short, the dihedral angle (theta) is obtained by first computing cos(theta) and sin(theta) using dot and cross products of the normal vectors of the two planes, and then computing theta using <code>torch.atan2</code>.</p> Tip <p>Here is a nice explanation of the computation of dihedral angles: https://leimao.github.io/blog/Dihedral-Angles</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>d</code> <code>Union[np.ndarray, torch.Tensor]</code> <p>3D coordinates of atom d (shape: (n, 3))</p> required <code>to_degree</code> <code>bool</code> <p>Whether to return dihedrals in degree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Dihedral angle between four points. (shape: (n,))</p>"},{"location":"reference/geometry/#protstruc.geometry.fix_chirality","title":"<code>fix_chirality(coords)</code>","text":"<p>Fix chirality of the backbone so that all the phi dihedrals are negative.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>np.array</code> <p>Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Fixed coordinates.</p>"},{"location":"reference/geometry/#protstruc.geometry.gram_schmidt","title":"<code>gram_schmidt(a, b, c)</code>","text":"<p>Given three xyz coordinates, compute the orthonormal basis using Gram-Schmidt process. Specifically, compute the orthonormal basis of the plane defined by vectors (c - b) and (a - b).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>b</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <code>c</code> <code>torch.Tensor</code> <p>xyz coordinates of three atoms (shape: (*, 3))</p> required <p>Returns:</p> Type Description <code>torch.FloatTensor</code> <p>Orthonormal basis of the plane defined by vectors <code>c - b</code> and <code>a - b</code>. Shape: (*, 3, 3)</p>"},{"location":"reference/geometry/#protstruc.geometry.ideal_backbone_coordinates","title":"<code>ideal_backbone_coordinates(size, include_cb=False)</code>","text":"<p>Return a batch of ideal backbone coordinates (N, Ca, C and optionally Cb) with a given batch size and number of residues.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Union[Tuple[int], List[int]]</code> required <code>include_cb</code> <code>bool</code> <p>Whether to include Cb atom in the frame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Union[np.array, torch.Tensor]</code> <p>A batch of ideal backbone coordinates (N, Ca, C and optionally Cb).</p> <code>Shape</code> <code>Union[np.array, torch.Tensor]</code> <p>(batch_size, num_residues, 3, 3) if <code>include_cb</code> is False, otherwise (batch_size, num_residues, 4, 3).</p>"},{"location":"reference/geometry/#protstruc.geometry.ideal_local_frame","title":"<code>ideal_local_frame()</code>","text":"<p>Compute ideal local coordinate system of a residue centered at N</p> <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>Local coordinate system of a residue centered at N, with atom order N, CA, C, CB (shape: (4, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.initialize_backbone_with_mds","title":"<code>initialize_backbone_with_mds(dist_mat, max_iter=500)</code>","text":"<p>Given a pairwise distance matrix of backbone atoms, initialize the coordinates of the backbone atoms using multidimensional scaling.</p> <p>Parameters:</p> Name Type Description Default <code>dist_mat</code> <code>np.array</code> <p>Pairwise distance matrix of backbone atoms (shape: (3, 3, L, L)).</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of iterations for MDS. Defaults to 500.</p> <code>500</code> <p>Returns:</p> Type Description <code>np.array</code> <p>np.array: Coordinates of backbone atoms (N, CA, C) (shape: (3, L, 3)).</p>"},{"location":"reference/geometry/#protstruc.geometry.place_fourth_atom","title":"<code>place_fourth_atom(a, b, c, length, planar, dihedral)</code>","text":"<p>Place a fourth atom X given three atoms (A, B and C) and the bond length (CX), planar angle (XCB), and dihedral angle (XCB vs ACB).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.array</code> <p>3D coordinates of atom a (shape: (n, 3))</p> required <code>b</code> <code>np.array</code> <p>3D coordinates of atom b (shape: (n, 3))</p> required <code>c</code> <code>np.array</code> <p>3D coordinates of atom c (shape: (n, 3))</p> required <code>length</code> <code>np.array</code> <p>Length of the bond between atom c and the new atom (shape: (n, 1)) i.e., bond length CX</p> required <code>planar</code> <code>np.array</code> <p>Planar angle between the new atom and the bond between atom c and the new atom (shape: (n, 1)) i.e., angle XCB</p> required <code>dihedral</code> <code>np.array</code> <p>Dihedral angle between the new atom and the plane defined by atoms a, b, and c (shape: (n, 1)) i.e., dihedral angle between planes XCB and ACB</p> required <p>Returns:</p> Type Description <code>Union[np.array, torch.Tensor]</code> <p>3D coordinates of the new atom X (shape: (n, 3))</p>"},{"location":"reference/geometry/#protstruc.geometry.reconstruct_backbone_distmat_from_interresidue_geometry","title":"<code>reconstruct_backbone_distmat_from_interresidue_geometry(d_cb, omega, theta, phi, mask=None, chain_breaks=None)</code>","text":"<p>Reconstruct the backbone distance matrix from interresidue geometry including Cb distance matrix (<code>d_cb</code>), Ca-Cb-Ca'-Cb' dihedral (<code>omega</code>), N-Ca-Cb-Cb' dihedral (<code>theta</code>), and Ca-Cb-Cb' planar angle (<code>phi</code>).</p> <p>Parameters:</p> Name Type Description Default <code>d_cb</code> <code>torch.Tensor</code> <p>Cb distance matrix (shape: (L, L))</p> required <code>omega</code> <code>torch.Tensor</code> <p>Ca-Cb-Ca'-Cb' dihedral matrix (shape: (L, L))</p> required <code>theta</code> <code>torch.Tensor</code> <p>N-Ca-Cb-Cb' dihedral matrix (shape: (L, L))</p> required <code>phi</code> <code>torch.Tensor</code> <p>Ca-Cb-Cb' planar angle matrix (shape: (L, L))</p> required <code>mask</code> <code>torch.Tensor</code> <p>Mask for valid residue pairs, i.e., pairs of residues whose distance can be reconstructed from interresidue geometry (shape: (L, L))</p> <code>None</code> <code>chain_breaks</code> <code>list</code> <p>List of chain breaks, i.e., indices of residues that are not in the same chain with the next one.</p> <code>None</code> <p>Returns:</p> Type Description <code>torch.Tensor</code> <p>Backbone distance matrix representing the distance between N, Ca, C atoms between residues (shape: (3, 3, L, L))</p>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#protstruc.io.infill_chain_idx","title":"<code>infill_chain_idx(chain_idx)</code>","text":"<p>Infill the chain index tensor to fill in the gaps.</p>"},{"location":"reference/io/#protstruc.io.pdb_to_xyz","title":"<code>pdb_to_xyz(filename)</code>","text":"<p>Parse a PDB file and return a tensor containing 3D coordinates of atoms.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to a PDB file.</p> required <p>Returns:</p> Name Type Description <code>atom_xyz</code> <code>torch.Tensor</code> <p>A xyz coordinate tensor. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE, 3).</p> <code>atom_mask</code> <code>torch.BoolTensor</code> <p>A mask tensor. 1 if the corresponding atom exists, 0 otherwise. Shape (n_residues, MAX_N_ATOMS_PER_RESIDUE)</p> <code>chain_idx</code> <code>torch.LongTensor</code> <p>A LongTensor containing chain indices per residue. Shape (n_residues,)</p> <code>chain_ids</code> <code>List[str]</code> <p>A list of unique chain IDs in the order of integers appearing in the <code>chain_idx</code> tensor.</p> <code>seq</code> <code>Dict[str, str]</code> <p>A dictionary mapping chain IDs to amino acid sequences.</p> Note <p><code>MAX_N_ATOMS_PER_RESIDUE</code> is set to 15 by default.</p>"},{"location":"reference/io/#protstruc.io.to_pdb","title":"<code>to_pdb(filename, coords, sequences, chain_ids, atoms=['N', 'CA', 'C', 'O', 'CB'])</code>","text":"<p>Save coordinates to a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output PDB file.</p> required <code>coords</code> <code>np.array</code> <p>Coordinates of shape (5, L, 3), where the first dimension denotes the atom type.</p> required <code>atoms</code> <code>List</code> <p>Defaults to [\"N\", \"CA\", \"C\", \"O\", \"CB\"].</p> <code>['N', 'CA', 'C', 'O', 'CB']</code>"},{"location":"tutorials/antibody_structure_batch/","title":"Using AntibodyStructureBatch","text":"<p>In this tutorial, we learn to use the convenient <code>get_cdr_mask</code> method of <code>AntibodyStructureBatch</code> to select CDRs from an antibody structure.</p> In\u00a0[1]: Copied! <pre>from protstruc import AntibodyStructureBatch\nfrom protstruc.general import ATOM\n\nimport matplotlib.pyplot as plt\nimport py3Dmol\n</pre> from protstruc import AntibodyStructureBatch from protstruc.general import ATOM  import matplotlib.pyplot as plt import py3Dmol In\u00a0[2]: Copied! <pre>pdb_paths = ['4uuj.pdb', '6dc4.pdb']\nheavy_chain_id = ['A', 'H']\nlight_chain_id = ['B', 'L']\nantigen_chain_ids = [['C'], None]  # no antigen for 6cd4\n</pre> pdb_paths = ['4uuj.pdb', '6dc4.pdb'] heavy_chain_id = ['A', 'H'] light_chain_id = ['B', 'L'] antigen_chain_ids = [['C'], None]  # no antigen for 6cd4 <p>First, to take a quick glance at their structures, let's use a handy <code>py3Dmol</code> library to interactively visualize them in the notebook.</p> In\u00a0[3]: Copied! <pre>def visualize_antibody(\n    pdb_fp,\n    heavy_chain_id,\n    light_chain_id,\n    antigen_chain_ids = None,\n    view_args={'width': 400, 'height': 400}\n):\n    with open(pdb_fp) as f:\n        protein = ''.join([x for x in f])\n\n    view = py3Dmol.view(**view_args)\n    view.addModel(protein, 'pdb')\n\n    view.setStyle({'chain': heavy_chain_id}, {'cartoon': {'color': 'cyan'}})\n    view.setStyle({'chain': light_chain_id}, {'cartoon': {'color': 'magenta'}})\n    if antigen_chain_ids is not None:\n        for chid in antigen_chain_ids:\n            view.setStyle({'chain': chid}, {'cartoon': {'color': 'grey'}})\n    view.zoomTo()\n\n    view.spin({'x': 2, 'y': 1.5, 'z': 1}, 0.5)\n    view.show()\n</pre> def visualize_antibody(     pdb_fp,     heavy_chain_id,     light_chain_id,     antigen_chain_ids = None,     view_args={'width': 400, 'height': 400} ):     with open(pdb_fp) as f:         protein = ''.join([x for x in f])      view = py3Dmol.view(**view_args)     view.addModel(protein, 'pdb')      view.setStyle({'chain': heavy_chain_id}, {'cartoon': {'color': 'cyan'}})     view.setStyle({'chain': light_chain_id}, {'cartoon': {'color': 'magenta'}})     if antigen_chain_ids is not None:         for chid in antigen_chain_ids:             view.setStyle({'chain': chid}, {'cartoon': {'color': 'grey'}})     view.zoomTo()      view.spin({'x': 2, 'y': 1.5, 'z': 1}, 0.5)     view.show() In\u00a0[4]: Copied! <pre>visualize_antibody(\n    '4uuj.pdb', 'A', 'B', 'C',\n    view_args={'width': 300, 'height': 300}\n)\nvisualize_antibody(\n    '6dc4.pdb', 'H', 'L', None,\n    view_args={'width': 300, 'height': 300}\n)\n</pre> visualize_antibody(     '4uuj.pdb', 'A', 'B', 'C',     view_args={'width': 300, 'height': 300} ) visualize_antibody(     '6dc4.pdb', 'H', 'L', None,     view_args={'width': 300, 'height': 300} ) <p>You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension:  jupyter labextension install jupyterlab_3dmol</p> <p>You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension:  jupyter labextension install jupyterlab_3dmol</p> In\u00a0[5]: Copied! <pre>asb = AntibodyStructureBatch.from_pdb(\n    pdb_paths, heavy_chain_id, light_chain_id, antigen_chain_ids,\n    numbering_scheme='chothia', keep_fv_only=False\n)\n</pre> asb = AntibodyStructureBatch.from_pdb(     pdb_paths, heavy_chain_id, light_chain_id, antigen_chain_ids,     numbering_scheme='chothia', keep_fv_only=False ) In\u00a0[6]: Copied! <pre>prt_idx = 0  # only deal with the first protein\n</pre> prt_idx = 0  # only deal with the first protein <p>The all-atom cloud of the protein looks like this:</p> In\u00a0[7]: Copied! <pre>xyz = asb.get_xyz()  # batch_size x n_residues x n_atoms x 3\nxyz_mask = asb.get_atom_mask().bool()  # batch_size x n_residues x n_atoms\n\nxyz, xyz_mask = xyz[prt_idx], xyz_mask[prt_idx]\n\nfig = plt.figure(figsize=(4, 4))\nax = fig.add_subplot(111, projection=\"3d\")\n\nax.scatter(\n    xyz[xyz_mask][:, 0],\n    xyz[xyz_mask][:, 1],\n    xyz[xyz_mask][:, 2],\n    alpha=0.1,\n)\nax.view_init(20, 80)\n</pre> xyz = asb.get_xyz()  # batch_size x n_residues x n_atoms x 3 xyz_mask = asb.get_atom_mask().bool()  # batch_size x n_residues x n_atoms  xyz, xyz_mask = xyz[prt_idx], xyz_mask[prt_idx]  fig = plt.figure(figsize=(4, 4)) ax = fig.add_subplot(111, projection=\"3d\")  ax.scatter(     xyz[xyz_mask][:, 0],     xyz[xyz_mask][:, 1],     xyz[xyz_mask][:, 2],     alpha=0.1, ) ax.view_init(20, 80) In\u00a0[8]: Copied! <pre>fig = plt.figure(figsize=(4, 4))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# obtain a boolean mask for each of the chains\nh_mask = asb.get_heavy_chain_mask()[prt_idx]\nl_mask = asb.get_light_chain_mask()[prt_idx]\nag_mask = asb.get_antigen_mask()[prt_idx]\n\nmasks = [h_mask, l_mask, ag_mask]\ncolors = ['C4', 'C5', 'C7']\nfor mask, c in zip(masks, colors):\n    xyz_masked = xyz[mask][xyz_mask[mask]]\n\n    ax.scatter(\n        xyz_masked[:, 0],\n        xyz_masked[:, 1],\n        xyz_masked[:, 2],\n        c=c,\n        alpha=0.1,\n    )\n\nax.view_init(20, 80)\n</pre> fig = plt.figure(figsize=(4, 4)) ax = fig.add_subplot(111, projection=\"3d\")  # obtain a boolean mask for each of the chains h_mask = asb.get_heavy_chain_mask()[prt_idx] l_mask = asb.get_light_chain_mask()[prt_idx] ag_mask = asb.get_antigen_mask()[prt_idx]  masks = [h_mask, l_mask, ag_mask] colors = ['C4', 'C5', 'C7'] for mask, c in zip(masks, colors):     xyz_masked = xyz[mask][xyz_mask[mask]]      ax.scatter(         xyz_masked[:, 0],         xyz_masked[:, 1],         xyz_masked[:, 2],         c=c,         alpha=0.1,     )  ax.view_init(20, 80) In\u00a0[9]: Copied! <pre>fig = plt.figure(figsize=(4, 4))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# obtain a boolean mask for each of the chains\nh_mask = asb.get_heavy_chain_mask()[prt_idx]\nl_mask = asb.get_light_chain_mask()[prt_idx]\nag_mask = asb.get_antigen_mask()[prt_idx]\n\nmasks = [h_mask, l_mask, ag_mask]\ncolors = ['C4', 'C5', 'C7']\nfor mask, c in zip(masks, colors):\n    xyz_masked = xyz[mask][xyz_mask[mask]]\n\n    ax.scatter(\n        xyz_masked[:, 0],\n        xyz_masked[:, 1],\n        xyz_masked[:, 2],\n        c=c,\n        alpha=0.05,\n    )\n\ncdrs = ['H1', 'H2', 'H3', 'L1', 'L2', 'L3']\nfor cdr in cdrs:\n    # `get_cdr_mask(subset)` returns a boolean mask for\n    # the corresponding CDRs.\n    cdr_mask = asb.get_cdr_mask(cdr)[prt_idx]\n\n    xyz_masked = xyz[cdr_mask][xyz_mask[cdr_mask]]\n    ax.scatter(\n        xyz_masked[:, 0],\n        xyz_masked[:, 1],\n        xyz_masked[:, 2],\n        c='C3',\n        alpha=0.5,\n    )\n\nax.view_init(20, 80)\n</pre> fig = plt.figure(figsize=(4, 4)) ax = fig.add_subplot(111, projection=\"3d\")  # obtain a boolean mask for each of the chains h_mask = asb.get_heavy_chain_mask()[prt_idx] l_mask = asb.get_light_chain_mask()[prt_idx] ag_mask = asb.get_antigen_mask()[prt_idx]  masks = [h_mask, l_mask, ag_mask] colors = ['C4', 'C5', 'C7'] for mask, c in zip(masks, colors):     xyz_masked = xyz[mask][xyz_mask[mask]]      ax.scatter(         xyz_masked[:, 0],         xyz_masked[:, 1],         xyz_masked[:, 2],         c=c,         alpha=0.05,     )  cdrs = ['H1', 'H2', 'H3', 'L1', 'L2', 'L3'] for cdr in cdrs:     # `get_cdr_mask(subset)` returns a boolean mask for     # the corresponding CDRs.     cdr_mask = asb.get_cdr_mask(cdr)[prt_idx]      xyz_masked = xyz[cdr_mask][xyz_mask[cdr_mask]]     ax.scatter(         xyz_masked[:, 0],         xyz_masked[:, 1],         xyz_masked[:, 2],         c='C3',         alpha=0.5,     )  ax.view_init(20, 80) <p>More precisely, we can only visualize Ca atoms like this:</p> In\u00a0[10]: Copied! <pre>fig = plt.figure(figsize=(4, 4))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# obtain a boolean mask for each of the chains\nh_mask = asb.get_heavy_chain_mask()[prt_idx]\nl_mask = asb.get_light_chain_mask()[prt_idx]\nag_mask = asb.get_antigen_mask()[prt_idx]\n\nmasks = [h_mask, l_mask, ag_mask]\ncolors = ['C4', 'C5', 'C7']\nfor mask, c in zip(masks, colors):\n    xyz_masked = xyz[mask, ATOM.CA]\n\n    ax.plot(\n        xyz_masked[:, 0],\n        xyz_masked[:, 1],\n        xyz_masked[:, 2],\n        c=c,\n        ls='--',\n        lw=0.75,\n    )\n\ncdrs = ['H1', 'H2', 'H3', 'L1', 'L2', 'L3']\nfor cdr in cdrs:\n    # `get_cdr_mask(subset)` returns a boolean mask for\n    # the corresponding CDRs.\n    cdr_mask = asb.get_cdr_mask(cdr)[prt_idx]\n\n    xyz_masked = xyz[cdr_mask, ATOM.CA]\n    ax.scatter(\n        xyz_masked[:, 0],\n        xyz_masked[:, 1],\n        xyz_masked[:, 2],\n        c='C3',\n    )\n\nax.view_init(20, 80)\n</pre> fig = plt.figure(figsize=(4, 4)) ax = fig.add_subplot(111, projection=\"3d\")  # obtain a boolean mask for each of the chains h_mask = asb.get_heavy_chain_mask()[prt_idx] l_mask = asb.get_light_chain_mask()[prt_idx] ag_mask = asb.get_antigen_mask()[prt_idx]  masks = [h_mask, l_mask, ag_mask] colors = ['C4', 'C5', 'C7'] for mask, c in zip(masks, colors):     xyz_masked = xyz[mask, ATOM.CA]      ax.plot(         xyz_masked[:, 0],         xyz_masked[:, 1],         xyz_masked[:, 2],         c=c,         ls='--',         lw=0.75,     )  cdrs = ['H1', 'H2', 'H3', 'L1', 'L2', 'L3'] for cdr in cdrs:     # `get_cdr_mask(subset)` returns a boolean mask for     # the corresponding CDRs.     cdr_mask = asb.get_cdr_mask(cdr)[prt_idx]      xyz_masked = xyz[cdr_mask, ATOM.CA]     ax.scatter(         xyz_masked[:, 0],         xyz_masked[:, 1],         xyz_masked[:, 2],         c='C3',     )  ax.view_init(20, 80)"},{"location":"tutorials/antibody_structure_batch/#highlighting-cdrs-with-get_cdr_mask","title":"Highlighting CDRs with <code>get_cdr_mask</code>\u00b6","text":"<p>We'll deal with two antibody structures:</p> <ul> <li>The first one is an murine antibody Fab structure binding to a component of a potassium channel complex (PDB ID: 4UUJ).</li> <li>The second one is a human respiratory syncytial virus (RSV)-neutralizing antibody Fab structure without an antigen. (PDB ID: 6DC4).</li> </ul>"},{"location":"tutorials/antibody_structure_batch/#initializing-an-antibodystructurebatch","title":"Initializing an <code>AntibodyStructureBatch</code>\u00b6","text":"<p>Next, let's initialize an <code>AntibodyStructureBatch</code> from the two pdb files we visualized above.</p> <p>Note that we use a renumbered antibody PDB files (downloaded from SAbDab database) as input. Among a handful of renumbering schemes out there, here we choose \"Chothia\" numbering scheme.</p> <p>Also note the <code>keep_fv_only</code> parameter. If this parameter is <code>True</code>, the parser discards the constant domains of Fab structures and only keeps the variable domains.</p>"},{"location":"tutorials/antibody_structure_batch/#visualizing-the-all-atom-cloud","title":"Visualizing the all-atom cloud\u00b6","text":"<p>That's it! Now you can check if the structure is correctly initialized. We are going to highlight and see the structural properties of CDRs using <code>get_cdr_mask</code> method.</p> <p>First, let's have a tensor of all-atom coordinates using <code>get_xyz</code> method and only focus on our first protein <code>4uuj</code>.</p>"},{"location":"tutorials/antibody_structure_batch/#coloring-by-chain-identity","title":"Coloring by chain identity\u00b6","text":"<p>What if we want to give different colors to different chains? We can retrieve some masks using <code>get_heavy_chain_mask</code>, <code>get_light_chain_mask</code> and <code>get_antigen_mask</code>, select those atoms and give them separate colors.</p>"},{"location":"tutorials/antibody_structure_batch/#highlighting-cdrs","title":"Highlighting CDRs\u00b6","text":"<p>Finally, we can additionally highlight the CDRs in the structure using <code>get_cdr_mask</code> method. You can easily see the CDRs (red) bound to the antigen (grey).</p>"},{"location":"tutorials/backbone_orientations_and_translations/","title":"Backbone orientations/translations","text":"<p>In this tutorial, we learn how to obtain backbone orientations and translations from protein structures using <code>protstruc</code>. For each residue, a 3x3 backbone orientation matrix is defined by a Gram-Schmidt orthonormalized basis of two vectors: N-Ca and C-Ca vectors. Meanwhile, a three-element translation vector is simply defined as a coordinate of the Ca atom.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import protstruc as ps import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) In\u00a0[3]: Copied! <pre>orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C').numpy()\ntranslations = sb.backbone_translations(atom='CA').numpy()\n\norientations.shape, translations.shape\n</pre> orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C').numpy() translations = sb.backbone_translations(atom='CA').numpy()  orientations.shape, translations.shape Out[3]: <pre>((2, 184, 3, 3), (2, 184, 3))</pre> In\u00a0[4]: Copied! <pre>from itertools import combinations\nfor i, j in combinations([0, 1, 2], 2):\n    inner_products = (orientations[:, :, :, i] * orientations[:, :, :, j]).sum(axis=2)\n\n    assert np.allclose(inner_products[~np.isnan(inner_products)], 0.0, atol=1e-6)\n</pre> from itertools import combinations for i, j in combinations([0, 1, 2], 2):     inner_products = (orientations[:, :, :, i] * orientations[:, :, :, j]).sum(axis=2)      assert np.allclose(inner_products[~np.isnan(inner_products)], 0.0, atol=1e-6) In\u00a0[5]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nprt_idx = 1\nchain_idx = sb.get_chain_idx()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n    # plot backbone CA atoms \n    ax.plot(\n        translations[prt_idx, chain_mask, 0],\n        translations[prt_idx, chain_mask, 1],\n        translations[prt_idx, chain_mask, 2],\n    )\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  prt_idx = 1 chain_idx = sb.get_chain_idx()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx     # plot backbone CA atoms      ax.plot(         translations[prt_idx, chain_mask, 0],         translations[prt_idx, chain_mask, 1],         translations[prt_idx, chain_mask, 2],     ) In\u00a0[6]: Copied! <pre>sb = ps.StructureBatch.from_pdb('4EOT.pdb')\nt = sb.backbone_translations()[0].numpy()\no = sb.backbone_orientations()[0].numpy()\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(111, projection='3d')\n\nprt_idx = 0\nchain_idx = sb.get_chain_idx()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n        \n    x, y, z = t[chain_mask, 0], t[chain_mask, 1], t[chain_mask, 2]\n    o_x, o_y, o_z = o[chain_mask, :, 0], o[chain_mask, :, 1], o[chain_mask, :, 2]\n\n    lw, length = 0.75, 1.5\n    ax.quiver(x, y, z, o_x[:, 0], o_x[:, 1], o_x[:, 2], color='C0', linewidth=lw, length=length)\n    ax.quiver(x, y, z, o_y[:, 0], o_y[:, 1], o_y[:, 2], color='C1', linewidth=lw, length=length)\n    ax.quiver(x, y, z, o_z[:, 0], o_z[:, 1], o_z[:, 2], color='C2', linewidth=lw, length=length)\n\n    ax.plot(x, y, z, c='C7', linewidth=0.5)\n    ax.view_init(30, 30)\n</pre> sb = ps.StructureBatch.from_pdb('4EOT.pdb') t = sb.backbone_translations()[0].numpy() o = sb.backbone_orientations()[0].numpy()  fig = plt.figure(figsize=(10, 10)) ax = fig.add_subplot(111, projection='3d')  prt_idx = 0 chain_idx = sb.get_chain_idx()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx              x, y, z = t[chain_mask, 0], t[chain_mask, 1], t[chain_mask, 2]     o_x, o_y, o_z = o[chain_mask, :, 0], o[chain_mask, :, 1], o[chain_mask, :, 2]      lw, length = 0.75, 1.5     ax.quiver(x, y, z, o_x[:, 0], o_x[:, 1], o_x[:, 2], color='C0', linewidth=lw, length=length)     ax.quiver(x, y, z, o_y[:, 0], o_y[:, 1], o_y[:, 2], color='C1', linewidth=lw, length=length)     ax.quiver(x, y, z, o_z[:, 0], o_z[:, 1], o_z[:, 2], color='C2', linewidth=lw, length=length)      ax.plot(x, y, z, c='C7', linewidth=0.5)     ax.view_init(30, 30) In\u00a0[7]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n\norientations = sb.backbone_orientations(a1='N', a2='CA', a3='C')\ntranslations = sb.backbone_translations(atom='CA')\n\norientations.shape, translations.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids)  orientations = sb.backbone_orientations(a1='N', a2='CA', a3='C') translations = sb.backbone_translations(atom='CA')  orientations.shape, translations.shape Out[7]: <pre>(torch.Size([2, 184, 3, 3]), torch.Size([2, 184, 3]))</pre> In\u00a0[8]: Copied! <pre>fig = plt.figure(figsize=(6, 4))\nax = fig.add_subplot(121, projection='3d')\nax2 = fig.add_subplot(122, projection='3d')\n\nprt_idx = 1\nchain_idx = sb.get_chain_idx()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n    # plot backbone CA atoms \n    ax.plot(\n        translations[prt_idx, chain_mask, 0].numpy(),\n        translations[prt_idx, chain_mask, 1].numpy(),\n        translations[prt_idx, chain_mask, 2].numpy(),\n    )\nax.set_title('Original')\n\n# Reinitialize StructureBatch only using backbone orientations and translations\nsb2 = ps.StructureBatch.from_backbone_orientations_translations(\n    orientations, translations, chain_idx, sb.get_chain_ids(), sb.get_seq()\n)\n\nt = sb2.backbone_translations()\n\nfor idx in [0, 1]:\n    chain_mask = chain_idx[prt_idx] == idx\n\n    ax2.plot(\n        t[prt_idx, chain_mask, 0].numpy(),\n        t[prt_idx, chain_mask, 1].numpy(),\n        t[prt_idx, chain_mask, 2].numpy(),\n    )\nax2.set_title('Reinitialized')\n</pre> fig = plt.figure(figsize=(6, 4)) ax = fig.add_subplot(121, projection='3d') ax2 = fig.add_subplot(122, projection='3d')  prt_idx = 1 chain_idx = sb.get_chain_idx()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx     # plot backbone CA atoms      ax.plot(         translations[prt_idx, chain_mask, 0].numpy(),         translations[prt_idx, chain_mask, 1].numpy(),         translations[prt_idx, chain_mask, 2].numpy(),     ) ax.set_title('Original')  # Reinitialize StructureBatch only using backbone orientations and translations sb2 = ps.StructureBatch.from_backbone_orientations_translations(     orientations, translations, chain_idx, sb.get_chain_ids(), sb.get_seq() )  t = sb2.backbone_translations()  for idx in [0, 1]:     chain_mask = chain_idx[prt_idx] == idx      ax2.plot(         t[prt_idx, chain_mask, 0].numpy(),         t[prt_idx, chain_mask, 1].numpy(),         t[prt_idx, chain_mask, 2].numpy(),     ) ax2.set_title('Reinitialized') Out[8]: <pre>Text(0.5, 0.92, 'Reinitialized')</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/backbone_orientations_and_translations/#extracting-backbone-orientations-and-translations-from-structurebatch-object","title":"Extracting backbone orientations and translations from <code>StructureBatch</code> object\u00b6","text":""},{"location":"tutorials/backbone_orientations_and_translations/#orthogonality-of-residue-frames-orientations","title":"Orthogonality of residue frames (orientations)\u00b6","text":"<p>Let's check whether vectors forming residue frames (which represent the orientation of residues) are orthogonal for each others.</p>"},{"location":"tutorials/backbone_orientations_and_translations/#visualizing-both-the-orientations-and-translations-of-residues","title":"Visualizing both the orientations and translations of residues\u00b6","text":""},{"location":"tutorials/backbone_orientations_and_translations/#initializing-a-new-structurebatch-object-from-residue-orientations-and-translations","title":"Initializing a new StructureBatch object from residue orientations and translations\u00b6","text":""},{"location":"tutorials/diffusing_xyz_coordinates/","title":"Diffusing XYZ coordinates with Gaussian noise","text":"<p>Many diffusion models for protein structure generation require a set of atom coordinates to be diffused with Gaussian noises having a predefined variance schedule, which finally results in a randomized set of coordinates distributed according to 3D Gaussian distribution. This tutorial shows how to use the <code>StructureBatch</code> object to generate a set of diffused coordinates.</p> In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport torch\n\nimport protstruc as ps\nfrom protstruc.general import ATOM\n</pre> import matplotlib.pyplot as plt import matplotlib.animation as animation import numpy as np import torch  import protstruc as ps from protstruc.general import ATOM In\u00a0[2]: Copied! <pre>import math\n\ndef cosine_variance_schedule(T, s=8e-3, beta_max=0.999):\n    # cosine variance schedule\n    # T: total timesteps\n    # s: small offset to prevent beta from being too small\n    # beta_max: to prevent singularities at the end of the diffusion process\n    t = torch.arange(T + 1)  # 0, 1, ..., T\n\n    f_t = torch.cos((t / T + s) / (1 + s) * math.pi / 2.0).square()\n    alpha_bar = f_t / f_t[0]\n    beta = torch.cat(\n        [\n            torch.tensor([0.0]),\n            torch.clip(1 - alpha_bar[1:] / alpha_bar[:-1], min=1e-5, max=beta_max),\n        ]\n    )\n    alpha = 1 - beta\n\n    sched = {\n        \"alpha\": alpha,\n        \"alpha_bar\": alpha_bar,\n        \"alpha_bar_sqrt\": alpha_bar.sqrt(),\n        \"one_minus_alpha_bar_sqrt\": (1 - alpha_bar).sqrt(),\n        \"beta\": beta,\n    }\n    return sched\n</pre> import math  def cosine_variance_schedule(T, s=8e-3, beta_max=0.999):     # cosine variance schedule     # T: total timesteps     # s: small offset to prevent beta from being too small     # beta_max: to prevent singularities at the end of the diffusion process     t = torch.arange(T + 1)  # 0, 1, ..., T      f_t = torch.cos((t / T + s) / (1 + s) * math.pi / 2.0).square()     alpha_bar = f_t / f_t[0]     beta = torch.cat(         [             torch.tensor([0.0]),             torch.clip(1 - alpha_bar[1:] / alpha_bar[:-1], min=1e-5, max=beta_max),         ]     )     alpha = 1 - beta      sched = {         \"alpha\": alpha,         \"alpha_bar\": alpha_bar,         \"alpha_bar_sqrt\": alpha_bar.sqrt(),         \"one_minus_alpha_bar_sqrt\": (1 - alpha_bar).sqrt(),         \"beta\": beta,     }     return sched In\u00a0[3]: Copied! <pre>pdb_id = '4EOT'\nsb = ps.StructureBatch.from_pdb_id(pdb_id)\nprt_idx = 0\natom_idx = ATOM.CA\n\nfig = plt.figure(figsize=(14, 5))\nax1 = fig.add_subplot(131, projection='3d')\nax2 = fig.add_subplot(132, projection='3d')\nax3 = fig.add_subplot(133)\n\nsb.standardize()\n \nT = 300\nsched = cosine_variance_schedule(T=T, s=8e-3, beta_max=0.999)\n\nxyz0 = sb.get_xyz()\nbsz, n_res = xyz0.shape[:2]\n\n# initial coordinates (t=0)\nxyz = xyz0\n\nims = []\nfor t in range(T):\n    # sample a noised structure from N( sqrt(1-b_{t}) * x_{t-1}, b_{t} * I).\n    xyz = torch.sqrt(1 - sched['beta'][t]) * xyz\n    xyz += torch.sqrt(sched['beta'][t]) * torch.randn(bsz, n_res, 1, 3)\n    \n    im1 = ax1.scatter(\n        xyz[prt_idx, :, atom_idx, 0].numpy(),\n        xyz[prt_idx, :, atom_idx, 1].numpy(),\n        xyz[prt_idx, :, atom_idx, 2].numpy(),\n        c='C1'\n    )\n    im2, = ax2.plot(\n        xyz[prt_idx, :, atom_idx, 0].numpy(),\n        xyz[prt_idx, :, atom_idx, 1].numpy(),\n        xyz[prt_idx, :, atom_idx, 2].numpy(),\n        c='C1'\n    )\n    # histogram of x coordinates\n    _, _, im3 = ax3.hist(xyz[prt_idx, :, atom_idx, 0], bins=33, fc='C1')\n    # axes title\n    t = ax3.text(0.5, 1.01, f't={t}', ha='center', va='bottom', transform=ax1.transAxes)\n    # histogram patches (im3) is already a list, so just concatenate it\n    ims.append([im1, im2, t] + list(im3))\n\nani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000)\nani.save(f'animations/{pdb_id}_diffusion.gif')\n\nplt.clf()  # not showing the results after this cell\n</pre> pdb_id = '4EOT' sb = ps.StructureBatch.from_pdb_id(pdb_id) prt_idx = 0 atom_idx = ATOM.CA  fig = plt.figure(figsize=(14, 5)) ax1 = fig.add_subplot(131, projection='3d') ax2 = fig.add_subplot(132, projection='3d') ax3 = fig.add_subplot(133)  sb.standardize()   T = 300 sched = cosine_variance_schedule(T=T, s=8e-3, beta_max=0.999)  xyz0 = sb.get_xyz() bsz, n_res = xyz0.shape[:2]  # initial coordinates (t=0) xyz = xyz0  ims = [] for t in range(T):     # sample a noised structure from N( sqrt(1-b_{t}) * x_{t-1}, b_{t} * I).     xyz = torch.sqrt(1 - sched['beta'][t]) * xyz     xyz += torch.sqrt(sched['beta'][t]) * torch.randn(bsz, n_res, 1, 3)          im1 = ax1.scatter(         xyz[prt_idx, :, atom_idx, 0].numpy(),         xyz[prt_idx, :, atom_idx, 1].numpy(),         xyz[prt_idx, :, atom_idx, 2].numpy(),         c='C1'     )     im2, = ax2.plot(         xyz[prt_idx, :, atom_idx, 0].numpy(),         xyz[prt_idx, :, atom_idx, 1].numpy(),         xyz[prt_idx, :, atom_idx, 2].numpy(),         c='C1'     )     # histogram of x coordinates     _, _, im3 = ax3.hist(xyz[prt_idx, :, atom_idx, 0], bins=33, fc='C1')     # axes title     t = ax3.text(0.5, 1.01, f't={t}', ha='center', va='bottom', transform=ax1.transAxes)     # histogram patches (im3) is already a list, so just concatenate it     ims.append([im1, im2, t] + list(im3))  ani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000) ani.save(f'animations/{pdb_id}_diffusion.gif')  plt.clf()  # not showing the results after this cell <pre>MovieWriter ffmpeg unavailable; using Pillow instead.\n</pre> <pre>&lt;Figure size 1400x500 with 0 Axes&gt;</pre> <p>The animation below shows that the coordinates of Ca atoms gradually reaches to the Gaussian distribution.</p> <p></p>"},{"location":"tutorials/ideal_backbone_coordinates/","title":"Ideal backbone coordinates","text":"In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import protstruc as ps import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nx = np.zeros(1)\ny = np.zeros(1)\nz = np.zeros(1)\n\nu = np.array([1])\nv = np.array([1])\nw = np.array([1])\n\nax.quiver(x, y, z, u, np.zeros_like(u), np.zeros_like(u), color='C0')\nax.quiver(x, y, z, np.zeros_like(v), v, np.zeros_like(v), color='C3')\nax.quiver(x, y, z, np.zeros_like(w), np.zeros_like(w), w, color='C7')\n\nax.set_xlim([-5, 5])\nax.set_ylim([-5, 5])\nax.set_zlim([-5, 5])\n</pre> fig = plt.figure() ax = fig.add_subplot(111, projection='3d')  x = np.zeros(1) y = np.zeros(1) z = np.zeros(1)  u = np.array([1]) v = np.array([1]) w = np.array([1])  ax.quiver(x, y, z, u, np.zeros_like(u), np.zeros_like(u), color='C0') ax.quiver(x, y, z, np.zeros_like(v), v, np.zeros_like(v), color='C3') ax.quiver(x, y, z, np.zeros_like(w), np.zeros_like(w), w, color='C7')  ax.set_xlim([-5, 5]) ax.set_ylim([-5, 5]) ax.set_zlim([-5, 5]) Out[2]: <pre>(-5.0, 5.0)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre>x\n</pre> x Out[3]: <pre>array([0.])</pre>"},{"location":"tutorials/pairwise_distance_matrix/","title":"Pairwise distance matrix","text":"<p>In this tutorial, we learn how to obtain pairwise distance matrix using <code>protstruc</code>.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\n\nfrom protstruc.general import ATOM, AA\nfrom biopandas.pdb import PandasPdb\n</pre> import protstruc as ps import matplotlib.pyplot as plt  from protstruc.general import ATOM, AA from biopandas.pdb import PandasPdb <p>Initialize a <code>StructureBatch</code> instance from a PDB IDs.</p> In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\ndistmat, distmat_mask = sb.pairwise_distance_matrix()\n\ndistmat.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids) distmat, distmat_mask = sb.pairwise_distance_matrix()  distmat.shape Out[2]: <pre>torch.Size([2, 184, 184, 15, 15])</pre> <p>Compute total number of residues for each protein.</p> In\u00a0[3]: Copied! <pre>total_lengths = sb.get_total_lengths()\ntotal_lengths\n</pre> total_lengths = sb.get_total_lengths() total_lengths Out[3]: <pre>tensor([130, 184])</pre> In\u00a0[4]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CA, ATOM.CA], distmat_mask[i, :, :, ATOM.CA, ATOM.CA]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])     ax.set_title(pdb_ids[i]) In\u00a0[5]: Copied! <pre>fig = plt.figure(figsize=(6, 3))\n\nfor i in range(2):\n    pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]\n    total_length = total_lengths[i]\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.matshow(pdist[:total_length, :total_length])\n\n    ax.set_title(pdb_ids[i])\n</pre> fig = plt.figure(figsize=(6, 3))  for i in range(2):     pdist, mask = distmat[i, :, :, ATOM.CB, ATOM.CB], distmat_mask[i, :, :, ATOM.CB, ATOM.CB]     total_length = total_lengths[i]      ax = fig.add_subplot(1, 2, i+1)     ax.matshow(pdist[:total_length, :total_length])      ax.set_title(pdb_ids[i])"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-ca-atoms","title":"Pairwise distance matrix between Ca atoms\u00b6","text":"<p>Note that 4EOT has 2 chains, so the pairwise distance matrix shows horizontal and vertical split.</p>"},{"location":"tutorials/pairwise_distance_matrix/#pairwise-distance-matrix-between-cb-atoms","title":"Pairwise distance matrix between Cb atoms\u00b6","text":"<p>Note that glycine residue does not have $C_{\\beta}$ atom and thus the distance from/to glycine residue is not defined.</p>"},{"location":"tutorials/parsing_antibody_pdb/","title":"Parsing antibody PDB files","text":"In\u00a0[2]: Copied! <pre>import pandas as pd\nimport numpy as np\nimport py3Dmol\n\nfrom biopandas.pdb import PandasPdb\n</pre> import pandas as pd import numpy as np import py3Dmol  from biopandas.pdb import PandasPdb In\u00a0[3]: Copied! <pre>from protstruc.pdb import ChothiaAntibodyPDB\n</pre> from protstruc.pdb import ChothiaAntibodyPDB In\u00a0[4]: Copied! <pre>def visualize_antibody(\n    pdb_fp,\n    heavy_chain_id,\n    light_chain_id,\n    antigen_chain_ids = None,\n    view_args={'width': 400, 'height': 400}\n):\n    with open(pdb_fp) as f:\n        protein = ''.join([x for x in f])\n\n    view = py3Dmol.view(**view_args)\n    view.addModel(protein, 'pdb')\n\n    view.setStyle({'chain': heavy_chain_id}, {'cartoon': {'color': 'cyan'}})\n    view.setStyle({'chain': light_chain_id}, {'cartoon': {'color': 'magenta'}})\n    if antigen_chain_ids is not None:\n        for chid in antigen_chain_ids:\n            view.setStyle({'chain': chid}, {'cartoon': {'color': 'grey'}})\n    view.zoomTo()\n\n    view.spin({'x': 2, 'y': 1.5, 'z': 1}, 0.5)\n    view.show()\n</pre> def visualize_antibody(     pdb_fp,     heavy_chain_id,     light_chain_id,     antigen_chain_ids = None,     view_args={'width': 400, 'height': 400} ):     with open(pdb_fp) as f:         protein = ''.join([x for x in f])      view = py3Dmol.view(**view_args)     view.addModel(protein, 'pdb')      view.setStyle({'chain': heavy_chain_id}, {'cartoon': {'color': 'cyan'}})     view.setStyle({'chain': light_chain_id}, {'cartoon': {'color': 'magenta'}})     if antigen_chain_ids is not None:         for chid in antigen_chain_ids:             view.setStyle({'chain': chid}, {'cartoon': {'color': 'grey'}})     view.zoomTo()      view.spin({'x': 2, 'y': 1.5, 'z': 1}, 0.5)     view.show() In\u00a0[19]: Copied! <pre>pdb_fp = '4uuj.pdb'\nvisualize_antibody(\n    pdb_fp,\n    heavy_chain_id='A',\n    light_chain_id='B',\n    antigen_chain_ids='C',\n    view_args={'width': 300, 'height': 300}\n)\n</pre> pdb_fp = '4uuj.pdb' visualize_antibody(     pdb_fp,     heavy_chain_id='A',     light_chain_id='B',     antigen_chain_ids='C',     view_args={'width': 300, 'height': 300} ) <p>You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension:  jupyter labextension install jupyterlab_3dmol</p> In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(10, 5))\nax = fig.add_subplot(121, projection='3d')\nax.set_title('Fab + antigen')\n\npdb = ChothiaAntibodyPDB.read_pdb(\"4uuj.pdb\", 'A', 'B', 'C', keep_fv_only=False)\natom_xyz, atom_xyz_mask = pdb.get_atom_xyz()\n\nhmask = pdb.get_heavy_chain_mask()\nlmask = pdb.get_light_chain_mask()\namask = pdb.get_antigen_mask()\n\nfor m, c in zip([hmask, lmask, amask], ['C3', 'C0', 'C7']):\n    ax.plot(\n        atom_xyz[m, 1, 0],\n        atom_xyz[m, 1, 1],\n        atom_xyz[m, 1, 2],\n        c=c,\n    )\nax.view_init(30, 30)\nxlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()\n\nax = fig.add_subplot(122, projection='3d')\nax.set_title('Fv + antigen')\n\npdb = ChothiaAntibodyPDB.read_pdb(\"4uuj.pdb\", 'A', 'B', 'C', keep_fv_only=True)\natom_xyz, atom_xyz_mask = pdb.get_atom_xyz()\n\nhmask = pdb.get_heavy_chain_mask()\nlmask = pdb.get_light_chain_mask()\namask = pdb.get_antigen_mask()\n\nfor m, c in zip([hmask, lmask, amask], ['C3', 'C0', 'C7']):\n    ax.plot(\n        atom_xyz[m, 1, 0],\n        atom_xyz[m, 1, 1],\n        atom_xyz[m, 1, 2],\n        c=c,\n    )\n\nax.view_init(30, 30)\nax.set_xlim(*xlim)\nax.set_ylim(*ylim)\nax.set_zlim(*zlim)\n</pre> import matplotlib.pyplot as plt  fig = plt.figure(figsize=(10, 5)) ax = fig.add_subplot(121, projection='3d') ax.set_title('Fab + antigen')  pdb = ChothiaAntibodyPDB.read_pdb(\"4uuj.pdb\", 'A', 'B', 'C', keep_fv_only=False) atom_xyz, atom_xyz_mask = pdb.get_atom_xyz()  hmask = pdb.get_heavy_chain_mask() lmask = pdb.get_light_chain_mask() amask = pdb.get_antigen_mask()  for m, c in zip([hmask, lmask, amask], ['C3', 'C0', 'C7']):     ax.plot(         atom_xyz[m, 1, 0],         atom_xyz[m, 1, 1],         atom_xyz[m, 1, 2],         c=c,     ) ax.view_init(30, 30) xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()  ax = fig.add_subplot(122, projection='3d') ax.set_title('Fv + antigen')  pdb = ChothiaAntibodyPDB.read_pdb(\"4uuj.pdb\", 'A', 'B', 'C', keep_fv_only=True) atom_xyz, atom_xyz_mask = pdb.get_atom_xyz()  hmask = pdb.get_heavy_chain_mask() lmask = pdb.get_light_chain_mask() amask = pdb.get_antigen_mask()  for m, c in zip([hmask, lmask, amask], ['C3', 'C0', 'C7']):     ax.plot(         atom_xyz[m, 1, 0],         atom_xyz[m, 1, 1],         atom_xyz[m, 1, 2],         c=c,     )  ax.view_init(30, 30) ax.set_xlim(*xlim) ax.set_ylim(*ylim) ax.set_zlim(*zlim) Out[26]: <pre>(-78.39299774169922, 33.999000549316406)</pre>"},{"location":"tutorials/parsing_antibody_pdb/#visualizing-fab-fv-and-antigen","title":"Visualizing Fab, Fv and antigen\u00b6","text":""},{"location":"tutorials/pembrolizumab/","title":"Pembrolizumab","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom protstruc import StructureBatch\n</pre> import matplotlib.pyplot as plt from protstruc import StructureBatch In\u00a0[2]: Copied! <pre>struc = StructureBatch.from_pdb_id('5dk3')\n</pre> struc = StructureBatch.from_pdb_id('5dk3') In\u00a0[4]: Copied! <pre>xyz = struc.get_xyz()\n</pre> xyz = struc.get_xyz() In\u00a0[6]: Copied! <pre>xyz.shape\n</pre> xyz.shape Out[6]: <pre>torch.Size([1, 1324, 15, 3])</pre> In\u00a0[87]: Copied! <pre>fig = plt.figure(figsize=(5, 5))\nax = fig.add_subplot(111, projection='3d')\nax.scatter(\n    xyz[0, :, :, 0], xyz[0, :, :, 1], xyz[0, :, :, 2],\n    alpha=0.1, c='C0'\n)\nax.view_init(-10, 20, 90)\nplt.savefig('../../img/pembrolizumab.png', dpi=300, bbox_inches='tight')\n</pre> fig = plt.figure(figsize=(5, 5)) ax = fig.add_subplot(111, projection='3d') ax.scatter(     xyz[0, :, :, 0], xyz[0, :, :, 1], xyz[0, :, :, 2],     alpha=0.1, c='C0' ) ax.view_init(-10, 20, 90) plt.savefig('../../img/pembrolizumab.png', dpi=300, bbox_inches='tight')  In\u00a0[107]: Copied! <pre>fig = plt.figure(figsize=(5, 5))\nax = fig.add_subplot(111, projection='3d')\n\nchain_idx = struc.get_chain_idx()[0]\nchain_ids = struc.get_chain_ids()[0]\n\ncolors = ['C3', 'C0', 'C1', 'C9']\nfor idx, (chain_id, c) in enumerate(zip(chain_ids, colors)):\n    mask = chain_idx == idx\n\n    ax.scatter(\n        xyz[0, mask, :, 0], xyz[0, mask, :, 1], xyz[0, mask, :, 2],\n        alpha=0.1, c=c\n    )\nax.view_init(-10, 20, 90)\nplt.savefig('../../img/pembrolizumab_chain.png', dpi=300, bbox_inches='tight')\n</pre> fig = plt.figure(figsize=(5, 5)) ax = fig.add_subplot(111, projection='3d')  chain_idx = struc.get_chain_idx()[0] chain_ids = struc.get_chain_ids()[0]  colors = ['C3', 'C0', 'C1', 'C9'] for idx, (chain_id, c) in enumerate(zip(chain_ids, colors)):     mask = chain_idx == idx      ax.scatter(         xyz[0, mask, :, 0], xyz[0, mask, :, 1], xyz[0, mask, :, 2],         alpha=0.1, c=c     ) ax.view_init(-10, 20, 90) plt.savefig('../../img/pembrolizumab_chain.png', dpi=300, bbox_inches='tight')  In\u00a0[118]: Copied! <pre>from protstruc.general import ATOM\n\nstruc = StructureBatch.from_pdb_id('5dk3')\ndistmat, distmat_mask = struc.pairwise_distance_matrix()\nplt.matshow(distmat[0, :, :, ATOM.CA, ATOM.CA]);\nplt.axis('off')\n\nplt.savefig('../../img/pembrolizumab_distmat.png', dpi=300, bbox_inches='tight')\n</pre> from protstruc.general import ATOM  struc = StructureBatch.from_pdb_id('5dk3') distmat, distmat_mask = struc.pairwise_distance_matrix() plt.matshow(distmat[0, :, :, ATOM.CA, ATOM.CA]); plt.axis('off')  plt.savefig('../../img/pembrolizumab_distmat.png', dpi=300, bbox_inches='tight')"},{"location":"tutorials/ramachandran_plot/","title":"Ramachandran plot","text":"<p>In this tutorial, we learn how to draw a Ramachandran plot by computing backbone dihedrals of a protein structure using <code>protstruc</code>.</p> In\u00a0[1]: Copied! <pre>import protstruc as ps\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import protstruc as ps import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>pdb_ids = ['1REX', '4EOT']\nsb = ps.StructureBatch.from_pdb_id(pdb_ids)\n\ndihedrals, dihedral_mask = sb.backbone_dihedrals()\ndihedrals.shape\n</pre> pdb_ids = ['1REX', '4EOT'] sb = ps.StructureBatch.from_pdb_id(pdb_ids)  dihedrals, dihedral_mask = sb.backbone_dihedrals() dihedrals.shape Out[2]: <pre>torch.Size([2, 184, 3])</pre> In\u00a0[3]: Copied! <pre>PHI_IDX, PSI_IDX = 0, 1\nfig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')\n\n    ax = fig.add_subplot(1, 2, i+1)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\nplt.subplots_adjust(wspace=0.3)\n</pre> PHI_IDX, PSI_IDX = 0, 1 fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     phi, psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      print(f'{pdb_ids[i]} has {residue_mask.sum()} residues valid for phi/psi plot.')      ax = fig.add_subplot(1, 2, i+1)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])  plt.subplots_adjust(wspace=0.3) <pre>1REX has 128 residues valid for phi/psi plot.\n4EOT has 180 residues valid for phi/psi plot.\n</pre> In\u00a0[4]: Copied! <pre>import biotite.structure as struc\nfrom biotite.structure.io.pdb import PDBFile\nfrom biotite.database.rcsb import fetch\nfetch(pdb_ids, 'pdb', '.')\n</pre> import biotite.structure as struc from biotite.structure.io.pdb import PDBFile from biotite.database.rcsb import fetch fetch(pdb_ids, 'pdb', '.') Out[4]: <pre>['./1REX.pdb', './4EOT.pdb']</pre> In\u00a0[5]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    ax.scatter(phi, psi, s=3)\n\n    ax.set_xlim(-np.pi, np.pi)\n    ax.set_ylim(-np.pi, np.pi)\n\n    ax.set_xlabel('phi ($\\phi$)')\n    ax.set_ylabel('psi ($\\psi$)')\n\n    ax.set_title(pdb_ids[i])\n\n    n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()\n    print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     ax.scatter(phi, psi, s=3)      ax.set_xlim(-np.pi, np.pi)     ax.set_ylim(-np.pi, np.pi)      ax.set_xlabel('phi ($\\phi$)')     ax.set_ylabel('psi ($\\psi$)')      ax.set_title(pdb_ids[i])      n_valid_residues = (~np.isnan(np.array([phi, psi]))).all(axis=0).sum()     print(f'{pdb_ids[i]} has {n_valid_residues} residues valid for phi/psi plot') plt.subplots_adjust(wspace=0.3)  <pre>1REX has 128 residues valid for phi/psi plot\n4EOT has 180 residues valid for phi/psi plot\n</pre> In\u00a0[6]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(phi, my_phi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('phi (biotite)')\n    ax.set_ylabel('phi (ProtStruc)')\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(phi, my_phi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('phi (biotite)')     ax.set_ylabel('phi (ProtStruc)') plt.subplots_adjust(wspace=0.3)  In\u00a0[7]: Copied! <pre>fig = plt.figure(figsize=(6.4, 3))\n\nfor i in range(2):\n    ax = fig.add_subplot(1, 2, i+1)\n\n    pdb_id = pdb_ids[i]\n    pdb = PDBFile.read(f'{pdb_id}.pdb')\n    structure = pdb.get_structure(model=1)\n\n    phi, psi, omega = struc.dihedral_backbone(structure)\n    mask = ~np.isnan(phi) &amp; ~np.isnan(psi)\n    phi, psi = phi[mask], psi[mask]\n\n    residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)\n    my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]\n\n    ax.scatter(psi, my_psi, s=3)\n    ax.set_title(pdb_ids[i])\n    ax.set_xlabel('psi (biotite)')\n    ax.set_ylabel('psi (ProtStruc)')\n\nplt.subplots_adjust(wspace=0.3)\n</pre> fig = plt.figure(figsize=(6.4, 3))  for i in range(2):     ax = fig.add_subplot(1, 2, i+1)      pdb_id = pdb_ids[i]     pdb = PDBFile.read(f'{pdb_id}.pdb')     structure = pdb.get_structure(model=1)      phi, psi, omega = struc.dihedral_backbone(structure)     mask = ~np.isnan(phi) &amp; ~np.isnan(psi)     phi, psi = phi[mask], psi[mask]      residue_mask = dihedral_mask[i, :, [PHI_IDX, PSI_IDX]].all(axis=-1)     my_phi, my_psi = dihedrals[i, residue_mask, PHI_IDX], dihedrals[i, residue_mask, PSI_IDX]      ax.scatter(psi, my_psi, s=3)     ax.set_title(pdb_ids[i])     ax.set_xlabel('psi (biotite)')     ax.set_ylabel('psi (ProtStruc)')  plt.subplots_adjust(wspace=0.3)"},{"location":"tutorials/ramachandran_plot/#compute-backbone-dihedrals-using-backbone_dihedrals","title":"Compute backbone dihedrals using <code>backbone_dihedrals()</code>\u00b6","text":"<p><code>backbone_dihedrals()</code> computes backbone dihedrals of a given protein structure and returns a tensor of shape <code>(B, L, 3)</code> where B is the batch size and L is the length of the protein. The last dimension denotes the three backbone dihedrals $\\phi$, $\\psi$ and $\\omega$.</p>"},{"location":"tutorials/ramachandran_plot/#ramachandran-plots","title":"Ramachandran plots\u00b6","text":"<p>Now plotting a Ramachandran plot is straightforward.</p> <p>We can see that protein <code>4EOT</code> is mainly composed of alpha helices.</p>"},{"location":"tutorials/ramachandran_plot/#benchmarking-with-biotitestructure","title":"Benchmarking with <code>biotite.structure</code>\u00b6","text":"<p>Now we check if the backbone dihedrals computed from <code>protstruc</code> is consistent with the results from <code>biotite.structure</code>.</p>"},{"location":"tutorials/rotating_structures/","title":"Rotating structures","text":"<p>In this tutorial, we learn how to rotate protein structures (representated as <code>StructureBatch</code>) using rotation matrices.</p> In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport protstruc as ps\nimport matplotlib.animation as animation\nimport numpy as np\nimport torch\n\npdb_id = '1REX'\n\nsb = ps.StructureBatch.from_pdb_id(pdb_id)\n# center the structure at the origin\nsb.center_at()\n\ntranslations = sb.backbone_translations()\ntranslations.shape\n</pre> import matplotlib.pyplot as plt import protstruc as ps import matplotlib.animation as animation import numpy as np import torch  pdb_id = '1REX'  sb = ps.StructureBatch.from_pdb_id(pdb_id) # center the structure at the origin sb.center_at()  translations = sb.backbone_translations() translations.shape Out[2]: <pre>torch.Size([1, 130, 3])</pre> In\u00a0[10]: Copied! <pre>fig = plt.figure(figsize=(5, 5))\nax = fig.add_subplot(111, projection='3d')\n\nchain_idx = sb.get_chain_idx()[0]\nnum_chains = int(chain_idx.max().item() + 1)\n\nsb.center_at()\n\nfor i in range(num_chains):\n    mask = chain_idx == i\n    # Plot the original structure\n    ax.plot(\n        translations[0, mask, 0].numpy(),\n        translations[0, mask, 1].numpy(),\n        translations[0, mask, 2].numpy(),\n        c='C7',\n        lw=0.75,\n    )\n    ax.scatter(\n        translations[0, mask, 0].numpy(),\n        translations[0, mask, 1].numpy(),\n        translations[0, mask, 2].numpy(),\n        c='C3',\n        s=10,\n        ec='none',\n    )\n</pre> fig = plt.figure(figsize=(5, 5)) ax = fig.add_subplot(111, projection='3d')  chain_idx = sb.get_chain_idx()[0] num_chains = int(chain_idx.max().item() + 1)  sb.center_at()  for i in range(num_chains):     mask = chain_idx == i     # Plot the original structure     ax.plot(         translations[0, mask, 0].numpy(),         translations[0, mask, 1].numpy(),         translations[0, mask, 2].numpy(),         c='C7',         lw=0.75,     )     ax.scatter(         translations[0, mask, 0].numpy(),         translations[0, mask, 1].numpy(),         translations[0, mask, 2].numpy(),         c='C3',         s=10,         ec='none',     )   In\u00a0[11]: Copied! <pre>from scipy.spatial.transform import Rotation as R\n\nfig = plt.figure(figsize=(5, 5))\nax = fig.add_subplot(111, projection='3d')\n\n# define an axis-angle rotation of 2*pi/100 around the z-axis\nrot = R.from_rotvec(np.array([0, 0, 1]) * 2 * np.pi / 100)\nrotmat = torch.tensor(rot.as_matrix()).float()\n\nims = []\nfor _ in range(100):\n    # here we rotate the structure by `rotmat` defined above\n    sb.rotate(rotmat)\n    translations = sb.backbone_translations()\n\n    tmp = []\n    for i in range(num_chains):\n        mask = chain_idx == i\n\n        im1, = ax.plot(\n            translations[0, mask, 0].numpy(),\n            translations[0, mask, 1].numpy(),\n            translations[0, mask, 2].numpy(),\n            c=f'C7',\n            lw=0.75,\n        )\n        im2 = ax.scatter(\n            translations[0, mask, 0].numpy(),\n            translations[0, mask, 1].numpy(),\n            translations[0, mask, 2].numpy(),\n            c='C3',\n            s=10,\n            ec='none',\n        )\n        tmp.append(im1)\n        tmp.append(im2)\n\n    ims.append(tmp)\n\nani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000)\nani.save(f'animations/{pdb_id}_rotation.gif')\n\nplt.clf();\n</pre>  from scipy.spatial.transform import Rotation as R  fig = plt.figure(figsize=(5, 5)) ax = fig.add_subplot(111, projection='3d')  # define an axis-angle rotation of 2*pi/100 around the z-axis rot = R.from_rotvec(np.array([0, 0, 1]) * 2 * np.pi / 100) rotmat = torch.tensor(rot.as_matrix()).float()  ims = [] for _ in range(100):     # here we rotate the structure by `rotmat` defined above     sb.rotate(rotmat)     translations = sb.backbone_translations()      tmp = []     for i in range(num_chains):         mask = chain_idx == i          im1, = ax.plot(             translations[0, mask, 0].numpy(),             translations[0, mask, 1].numpy(),             translations[0, mask, 2].numpy(),             c=f'C7',             lw=0.75,         )         im2 = ax.scatter(             translations[0, mask, 0].numpy(),             translations[0, mask, 1].numpy(),             translations[0, mask, 2].numpy(),             c='C3',             s=10,             ec='none',         )         tmp.append(im1)         tmp.append(im2)      ims.append(tmp)  ani = animation.ArtistAnimation(fig, ims, interval=100, blit=True, repeat_delay=1000) ani.save(f'animations/{pdb_id}_rotation.gif')  plt.clf(); <pre>MovieWriter ffmpeg unavailable; using Pillow instead.\n</pre> <pre>&lt;Figure size 500x500 with 0 Axes&gt;</pre> <p></p>"}]}